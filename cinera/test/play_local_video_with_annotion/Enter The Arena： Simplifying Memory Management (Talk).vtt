WEBVTT

1
00:00:00.169 --> 00:00:00.690
<v SPEAKER_00> Welcome, everybody.

2
00:00:00.830 --> 00:00:01.410
<v SPEAKER_00>Great to have you here.

3
00:00:01.710 --> 00:00:03.051
<v SPEAKER_00>I'm really excited to talk to you all.

4
00:00:03.552 --> 00:00:06.834
<v SPEAKER_00>Abner alluded, I'll be speaking to you all about everyone's favorite topic.

5
00:00:06.874 --> 00:00:10.097
<v SPEAKER_00>Everyone loves to think about this all the time, which is manual memory management.

6
00:00:10.637 --> 00:00:15.401
<v SPEAKER_00>And despite how I know, like, good thing I'm first thing in the morning, right?

7
00:00:15.681 --> 00:00:16.682
<v SPEAKER_00>Hope everyone had their caffeine.

8
00:00:17.823 --> 00:00:19.865
<v SPEAKER_00>So despite how boring that may sound,

9
00:00:19.905 --> 00:00:21.806
<v SPEAKER_00>this is something that every programmer,

10
00:00:21.966 --> 00:00:22.667
<v SPEAKER_00>systems programmers,

11
00:00:22.687 --> 00:00:24.028
<v SPEAKER_00>but all the way up to higher level languages,

12
00:00:24.068 --> 00:00:26.890
<v SPEAKER_00>they need to at least be familiar with this problem.

13
00:00:26.930 --> 00:00:28.972
<v SPEAKER_00>And knowing how you would approach the problem at a lower level

14
00:00:29.844 --> 00:00:33.365
<v SPEAKER_00> will even improve you as a programmer at the very highest levels.

15
00:00:33.585 --> 00:00:37.826
<v SPEAKER_00>So that's what I'm here to talk to you about today.

16
00:00:41.087 --> 00:00:42.507
<v SPEAKER_00>So I'll get started with an audience poll.

17
00:00:42.527 --> 00:00:49.869
<v SPEAKER_00>Go ahead and raise your hand if you believe yourself or have ever been told one of the following things.

18
00:00:50.709 --> 00:00:51.569
<v SPEAKER_00>I've got to zoom in here.

19
00:00:52.349 --> 00:00:55.170
<v SPEAKER_00>Manual memory management is complex and difficult to do correctly.

20
00:00:56.851 --> 00:00:58.411
<v SPEAKER_00>Manual memory management is bug prone.

21
00:00:59.775 --> 00:01:01.675
<v SPEAKER_00> Manual memory management leads to memory unsafety.

22
00:01:02.156 --> 00:01:03.616
<v SPEAKER_00>It's extra effort for no tangible win.

23
00:01:03.676 --> 00:01:09.057
<v SPEAKER_00>Garbage collection, automatic reference counting, RAII, et cetera, are required to address this problem.

24
00:01:09.337 --> 00:01:11.718
<v SPEAKER_00>And memory management is only relevant for low-level systems programs.

25
00:01:11.758 --> 00:01:15.618
<v SPEAKER_00>How many people have heard that from a coworker, teacher, et cetera?

26
00:01:16.218 --> 00:01:16.378
<v SPEAKER_00>Right.

27
00:01:16.619 --> 00:01:16.799
<v SPEAKER_00>OK.

28
00:01:16.839 --> 00:01:17.059
<v SPEAKER_00>Yes.

29
00:01:17.459 --> 00:01:18.919
<v SPEAKER_00>Everyone should raise their hands.

30
00:01:18.979 --> 00:01:23.100
<v SPEAKER_00>These are things that everyone is told from day one of learning how to program.

31
00:01:24.984 --> 00:01:25.805
<v SPEAKER_00>And I was told those things,

32
00:01:25.845 --> 00:01:26.065
<v SPEAKER_00>too,

33
00:01:26.785 --> 00:01:33.209
<v SPEAKER_00>originally when I first started programming until I was introduced to Handmade Hero.

34
00:01:34.129 --> 00:01:35.450
<v SPEAKER_00>And the host of Handmade Hero,

35
00:01:35.550 --> 00:01:35.950
<v SPEAKER_00>Casey,

36
00:01:36.510 --> 00:01:37.571
<v SPEAKER_00>he would say things like,

37
00:01:39.232 --> 00:01:42.733
<v SPEAKER_00>people don't usually believe me when I say I don't spend time thinking about memory management,

38
00:01:43.054 --> 00:01:43.934
<v SPEAKER_00>and I really just don't.

39
00:01:44.394 --> 00:01:46.675
<v SPEAKER_00>Most of the time, it seems like it just handles itself.

40
00:01:46.776 --> 00:01:51.278
<v SPEAKER_00>And so when you're coming from a perspective informed by statements that I had at the beginning,

41
00:01:52.776 --> 00:01:54.317
<v SPEAKER_00>You hear Casey,

42
00:01:54.357 --> 00:01:55.997
<v SPEAKER_00>who clearly knew what he was doing and everything,

43
00:01:56.398 --> 00:01:57.318
<v SPEAKER_00>you hear him say stuff like that,

44
00:01:57.358 --> 00:01:58.018
<v SPEAKER_00>and you're kind of like,

45
00:01:58.659 --> 00:01:59.759
<v SPEAKER_00>what in the world is he talking about?

46
00:01:59.819 --> 00:02:02.300
<v SPEAKER_00>It goes against everything we're told from day one.

47
00:02:03.301 --> 00:02:04.361
<v SPEAKER_00>So I was really intrigued.

48
00:02:05.082 --> 00:02:10.204
<v SPEAKER_00>And I dug into Handmade Hero and throughout my time watching it and throughout my

49
00:02:10.264 --> 00:02:15.266
<v SPEAKER_00>time working on a bunch of projects inspired by Handmade Hero's philosophy over the

50
00:02:15.286 --> 00:02:15.907
<v SPEAKER_00>next few years,

51
00:02:16.807 --> 00:02:19.728
<v SPEAKER_00>I learned a bunch of techniques that I thought were really useful for me

52
00:02:21.129 --> 00:02:24.611
<v SPEAKER_00> basically getting me to the point that Casey was when he recorded this.

53
00:02:24.631 --> 00:02:26.652
<v SPEAKER_00>I don't think about these things really anymore.

54
00:02:27.653 --> 00:02:29.554
<v SPEAKER_00>And I think the techniques can be pretty simple.

55
00:02:29.574 --> 00:02:31.855
<v SPEAKER_00>I don't think they're as hard as people might think.

56
00:02:31.915 --> 00:02:35.257
<v SPEAKER_00>So I'm here to tell you all about them today.

57
00:02:37.458 --> 00:02:40.180
<v SPEAKER_00>Handmade Heroes' approach was to start from first principles, right?

58
00:02:40.920 --> 00:02:41.881
<v SPEAKER_00>Understand from the ground up.

59
00:02:42.361 --> 00:02:48.665
<v SPEAKER_00>So let's understand memory from that perspective and see what we can come up with.

60
00:02:51.041 --> 00:02:53.464
<v SPEAKER_00> So this might be a diagram that people have seen before.

61
00:02:53.484 --> 00:02:54.044
<v SPEAKER_00>This is how,

62
00:02:54.284 --> 00:02:57.368
<v SPEAKER_00>if you've taken a computer science program at a university,

63
00:02:57.888 --> 00:03:00.431
<v SPEAKER_00>you've probably seen something like this before.

64
00:03:00.471 --> 00:03:03.774
<v SPEAKER_00>This is like a logical circuit diagram for what's called a flip flop.

65
00:03:05.137 --> 00:03:06.058
<v SPEAKER_00> I'm not a hardware person.

66
00:03:06.078 --> 00:03:08.119
<v SPEAKER_00>I don't know where this shows up.

67
00:03:08.159 --> 00:03:09.660
<v SPEAKER_00>It's probably not used everywhere.

68
00:03:09.780 --> 00:03:15.964
<v SPEAKER_00>There's probably subtleties in how the concept of memory is implemented in different circumstances.

69
00:03:16.004 --> 00:03:19.146
<v SPEAKER_00>But the effect that this provides is the important part that I want to get at.

70
00:03:19.966 --> 00:03:23.248
<v SPEAKER_00>You'll see that if you imagine this circuit flowing from left to right,

71
00:03:24.008 --> 00:03:25.449
<v SPEAKER_00>that it has a distinctive shape,

72
00:03:25.469 --> 00:03:27.330
<v SPEAKER_00>which is that this circuit loops back in on itself.

73
00:03:28.111 --> 00:03:29.632
<v SPEAKER_00>So it retains a stable state.

74
00:03:31.761 --> 00:03:34.122
<v SPEAKER_00> And it can either be in one of two configurations.

75
00:03:34.182 --> 00:03:37.463
<v SPEAKER_00>It could be returning high on the state wire going out,

76
00:03:38.184 --> 00:03:41.925
<v SPEAKER_00>or it can be returning high on the flip state wire.

77
00:03:42.065 --> 00:03:43.526
<v SPEAKER_00>So this is called a flip-flop.

78
00:03:43.906 --> 00:03:45.527
<v SPEAKER_00>There's a lot of different ways to build one,

79
00:03:45.567 --> 00:03:46.547
<v SPEAKER_00>but this is just like,

80
00:03:46.988 --> 00:03:48.688
<v SPEAKER_00>I googled a diagram of a flip-flop,

81
00:03:49.128 --> 00:03:49.689
<v SPEAKER_00>and this is like,

82
00:03:50.874 --> 00:03:52.395
<v SPEAKER_00> The first one I found.

83
00:03:52.435 --> 00:03:55.157
<v SPEAKER_00>So I was like, let me just draw it in Milton and then put it on the slide.

84
00:03:56.398 --> 00:03:58.679
<v SPEAKER_00>And that implements the effect of one bit,

85
00:03:59.460 --> 00:04:05.824
<v SPEAKER_00>which a bit is just capable of encoding one of two possible values or one of two

86
00:04:05.864 --> 00:04:07.505
<v SPEAKER_00>possible states.

87
00:04:08.866 --> 00:04:13.509
<v SPEAKER_00>And with every additional bit we add to sort of a group of bits, if we consider multiple together,

88
00:04:14.825 --> 00:04:18.186
<v SPEAKER_00> Each bit multiplies the number of possible values we can encode by 2.

89
00:04:18.246 --> 00:04:21.506
<v SPEAKER_00>So if you have n bits, you get 2 to the n possible values.

90
00:04:23.547 --> 00:04:24.787
<v SPEAKER_00>Why is that important?

91
00:04:24.807 --> 00:04:25.307
<v SPEAKER_00>Why do we care?

92
00:04:25.947 --> 00:04:28.848
<v SPEAKER_00>Well, in 2014, Mike Acton gave this wonderful talk.

93
00:04:28.928 --> 00:04:33.149
<v SPEAKER_00>I got this screenshot from a very wonderful moment in the Q&A session.

94
00:04:34.009 --> 00:04:35.649
<v SPEAKER_00>I just thought it was very, very good.

95
00:04:35.869 --> 00:04:38.970
<v SPEAKER_00>So in that talk, he explained the following idea.

96
00:04:39.330 --> 00:04:42.411
<v SPEAKER_00>All computation is expressed as data transforms.

97
00:04:42.431 --> 00:04:43.611
<v SPEAKER_00>You start with some input data.

98
00:04:45.476 --> 00:04:47.678
<v SPEAKER_00>And through some computational transform,

99
00:04:47.918 --> 00:04:49.980
<v SPEAKER_00>you produce some output data,

100
00:04:50.020 --> 00:04:50.781
<v SPEAKER_00>so A to B.

101
00:04:51.382 --> 00:04:56.066
<v SPEAKER_00>And that's like a high level model that can sort of apply generally to everything

102
00:04:56.106 --> 00:04:56.687
<v SPEAKER_00>computers do.

103
00:04:58.849 --> 00:04:59.750
<v SPEAKER_00>But on computers,

104
00:05:01.112 --> 00:05:02.033
<v SPEAKER_00> What are A and B?

105
00:05:02.073 --> 00:05:05.596
<v SPEAKER_00>Well, those are implemented through data which is stored in memory.

106
00:05:05.636 --> 00:05:08.499
<v SPEAKER_00>So that's why we care about encoding things into memory.

107
00:05:08.619 --> 00:05:12.422
<v SPEAKER_00>Every single code path you ever write looks like A to B.

108
00:05:12.982 --> 00:05:15.324
<v SPEAKER_00>And so if you're a render programmer,

109
00:05:15.484 --> 00:05:15.925
<v SPEAKER_00>all you're doing,

110
00:05:16.125 --> 00:05:16.986
<v SPEAKER_00>like your A,

111
00:05:17.586 --> 00:05:18.847
<v SPEAKER_00>is the game level state.

112
00:05:19.608 --> 00:05:21.529
<v SPEAKER_00>And your B is the frame buffer that you're producing.

113
00:05:23.190 --> 00:05:24.511
<v SPEAKER_00>If you're a gameplay programmer,

114
00:05:25.111 --> 00:05:27.673
<v SPEAKER_00>your A is the game state at time 0,

115
00:05:27.673 --> 00:05:29.474
<v SPEAKER_00>and then your B is the game state at time 1.

116
00:05:30.234 --> 00:05:31.175
<v SPEAKER_00>If you're a UI programmer,

117
00:05:31.195 --> 00:05:34.096
<v SPEAKER_00>it's the application state on the left and then the UI data structure on the right.

118
00:05:34.976 --> 00:05:38.198
<v SPEAKER_00>And if you're writing a compiler or a parser,

119
00:05:39.139 --> 00:05:41.900
<v SPEAKER_00>you're starting with text on the left and then producing an abstract syntax tree on

120
00:05:41.940 --> 00:05:42.200
<v SPEAKER_00>the right.

121
00:05:43.020 --> 00:05:45.182
<v SPEAKER_00>And all of those things are stored in memory.

122
00:05:45.842 --> 00:05:47.383
<v SPEAKER_00>And then a computer just transforms that.

123
00:05:49.537 --> 00:05:50.978
<v SPEAKER_00>And if we dig one layer down,

124
00:05:50.998 --> 00:05:56.820
<v SPEAKER_00>you can imagine projecting each side of those arrows into a spatial representation.

125
00:05:56.860 --> 00:05:59.721
<v SPEAKER_00>Obviously, not to scale or anything, obviously.

126
00:05:59.761 --> 00:06:04.623
<v SPEAKER_00>But every single one of those things ends up in memory somewhere,

127
00:06:04.923 --> 00:06:07.845
<v SPEAKER_00>out of this big pool of available memory on a computer.

128
00:06:07.965 --> 00:06:10.146
<v SPEAKER_00>Now, a couple things are interesting when you look at it from this angle.

129
00:06:10.206 --> 00:06:12.747
<v SPEAKER_00>First of all, I can use the laser pointer.

130
00:06:14.257 --> 00:06:16.398
<v SPEAKER_00> The code itself requires memory.

131
00:06:16.898 --> 00:06:18.039
<v SPEAKER_00>So that ends up there somewhere.

132
00:06:19.240 --> 00:06:20.681
<v SPEAKER_00>A and B can also overlap.

133
00:06:21.421 --> 00:06:23.303
<v SPEAKER_00>You have the game state.

134
00:06:23.523 --> 00:06:26.645
<v SPEAKER_00>There's a tick code path that just applies transform to the same memory.

135
00:06:27.465 --> 00:06:31.528
<v SPEAKER_00>And then everything else just reads from one and then writes to the other.

136
00:06:32.589 --> 00:06:35.571
<v SPEAKER_00>And then obviously these could overlap in more subtle ways and everything is very high level.

137
00:06:39.400 --> 00:06:42.963
<v SPEAKER_00> So if we zoom into one particular code path, what does it look like?

138
00:06:43.483 --> 00:06:47.467
<v SPEAKER_00>Well, I mean, we actually got to see a little bit of this with the first part of Kaze's video.

139
00:06:48.047 --> 00:06:48.548
<v SPEAKER_00>But I mean,

140
00:06:48.628 --> 00:06:50.189
<v SPEAKER_00>you grab memory from some address,

141
00:06:50.209 --> 00:06:52.031
<v SPEAKER_00>you apply some transform locally on the CPU,

142
00:06:52.051 --> 00:06:54.112
<v SPEAKER_00>and you store it back to some other address.

143
00:06:54.132 --> 00:06:55.053
<v SPEAKER_00>Well, what is an address?

144
00:06:57.115 --> 00:06:58.716
<v SPEAKER_00>Well, most people will tell you that it looks like this.

145
00:06:59.217 --> 00:07:04.761
<v SPEAKER_00>And this is like a fine starting mental model, where an address is just a number.

146
00:07:05.162 --> 00:07:06.182
<v SPEAKER_00>It's also encoded as data.

147
00:07:07.986 --> 00:07:10.169
<v SPEAKER_00> And it refers to some unit of memory.

148
00:07:12.712 --> 00:07:16.316
<v SPEAKER_00>And people will tell you that the ordering is linear like this.

149
00:07:16.336 --> 00:07:18.618
<v SPEAKER_00>So if you have 0, it refers to the first byte in physical memory.

150
00:07:18.638 --> 00:07:20.260
<v SPEAKER_00>1 goes to the next byte.

151
00:07:21.321 --> 00:07:23.964
<v SPEAKER_00>People tell you to think about memory as maybe like a big array of bytes.

152
00:07:25.346 --> 00:07:26.547
<v SPEAKER_00>And so if you take that model,

153
00:07:26.567 --> 00:07:28.909
<v SPEAKER_00>you can imagine also looking at that code path,

154
00:07:29.089 --> 00:07:32.271
<v SPEAKER_00>it would grab eight bytes from some 8K address,

155
00:07:32.812 --> 00:07:33.412
<v SPEAKER_00>8K or whatever,

156
00:07:34.333 --> 00:07:36.034
<v SPEAKER_00>compute some transform on those bytes,

157
00:07:36.595 --> 00:07:40.217
<v SPEAKER_00>and then store those eight bytes back to some different address,

158
00:07:40.377 --> 00:07:41.578
<v SPEAKER_00>some destination address,

159
00:07:41.598 --> 00:07:41.618
<v SPEAKER_00>16K.

160
00:07:44.761 --> 00:07:51.547
<v SPEAKER_00> But on modern CPUs, this is not really totally the full picture.

161
00:07:52.488 --> 00:07:57.172
<v SPEAKER_00>Because you can also consider that mapping could be something very different.

162
00:07:57.752 --> 00:08:02.677
<v SPEAKER_00>Each address could go to some completely different place in physical memory that

163
00:08:02.697 --> 00:08:04.678
<v SPEAKER_00>you wouldn't have otherwise known.

164
00:08:05.899 --> 00:08:07.180
<v SPEAKER_00>And so what we call on the left

165
00:08:08.260 --> 00:08:11.823
<v SPEAKER_00>is this virtual address space concept,

166
00:08:12.484 --> 00:08:16.467
<v SPEAKER_00>which is the space of all possible addresses that you're talking about.

167
00:08:17.408 --> 00:08:19.930
<v SPEAKER_00>And then on the right, you have physical memory.

168
00:08:20.270 --> 00:08:25.015
<v SPEAKER_00>And every time the CPU will take an address that you've written into your code,

169
00:08:25.415 --> 00:08:29.578
<v SPEAKER_00>it'll feed it through this mapping and produce from your virtual address,

170
00:08:29.638 --> 00:08:30.099
<v SPEAKER_00>as they're called,

171
00:08:30.339 --> 00:08:31.480
<v SPEAKER_00>it'll produce a physical address.

172
00:08:31.500 --> 00:08:34.623
<v SPEAKER_00>And that's where it'll actually load or store things.

173
00:08:37.563 --> 00:08:40.104
<v SPEAKER_00> And now you might wonder why people decided to do that.

174
00:08:40.424 --> 00:08:41.424
<v SPEAKER_00>And there's a lot of good reasons.

175
00:08:41.705 --> 00:08:47.447
<v SPEAKER_00>But first interesting detail is that a virtual address space tends to be,

176
00:08:47.547 --> 00:08:48.627
<v SPEAKER_00>like on all your laptops,

177
00:08:48.647 --> 00:08:49.187
<v SPEAKER_00>for example,

178
00:08:49.607 --> 00:08:53.909
<v SPEAKER_00>it's going to be 48 bits worth of possible addresses you can use.

179
00:08:55.009 --> 00:08:55.850
<v SPEAKER_00>And I told you.

180
00:08:57.762 --> 00:09:00.963
<v SPEAKER_00> N bits gives you 2 to the n possible values.

181
00:09:01.423 --> 00:09:03.784
<v SPEAKER_00>So 48 bits gives you 2 to the 48 possible values,

182
00:09:03.804 --> 00:09:08.305
<v SPEAKER_00>which is enough to refer to about 256 terabytes of memory.

183
00:09:08.585 --> 00:09:09.525
<v SPEAKER_00>Now, you may be a little confused.

184
00:09:09.665 --> 00:09:12.426
<v SPEAKER_00>You're like, I didn't put 256 terabytes of memory in my machine.

185
00:09:13.186 --> 00:09:16.147
<v SPEAKER_00>I put two RAM sticks, each of which were 8 gigabytes or something like that.

186
00:09:16.807 --> 00:09:21.428
<v SPEAKER_00>And so the physical memory side has a much more constrained limitation on it.

187
00:09:24.212 --> 00:09:25.354
<v SPEAKER_00> And so why would people do that?

188
00:09:25.394 --> 00:09:32.006
<v SPEAKER_00>Well, it gives flexibility, because each address space, considered independently,

189
00:09:34.582 --> 00:09:35.003
<v SPEAKER_00>Someone,

190
00:09:35.643 --> 00:09:36.324
<v SPEAKER_00>the operating system,

191
00:09:36.584 --> 00:09:40.749
<v SPEAKER_00>can make decisions about which portions of addresses you're talking about,

192
00:09:41.430 --> 00:09:44.454
<v SPEAKER_00>how and where they're reflected in physical addresses,

193
00:09:45.535 --> 00:09:46.356
<v SPEAKER_00>in physical memory.

194
00:09:46.396 --> 00:09:47.437
<v SPEAKER_00>And then other pages,

195
00:09:47.477 --> 00:09:51.522
<v SPEAKER_00>like maybe something that you're not accessing very frequently inside of your program,

196
00:09:51.962 --> 00:09:53.524
<v SPEAKER_00>those things can be paged out to disk.

197
00:09:57.241 --> 00:10:02.082
<v SPEAKER_00> And so you can see there's a very clean division between these two address spaces.

198
00:10:02.142 --> 00:10:06.283
<v SPEAKER_00>The operating system is sort of managing one process, which only has one address space.

199
00:10:06.303 --> 00:10:08.644
<v SPEAKER_00>It can only talk about addresses in its address space.

200
00:10:08.684 --> 00:10:10.784
<v SPEAKER_00>It can't talk about this thing over here.

201
00:10:11.585 --> 00:10:17.666
<v SPEAKER_00>But if we consider within one single address space, what's the problem?

202
00:10:18.601 --> 00:10:19.122
<v SPEAKER_00>Well,

203
00:10:19.822 --> 00:10:24.527
<v SPEAKER_00>if you just throw everything you know about programming out the window and consider

204
00:10:24.547 --> 00:10:25.468
<v SPEAKER_00>what I've told you so far,

205
00:10:26.289 --> 00:10:29.612
<v SPEAKER_00>all I've told you is that people read from addresses and write to addresses.

206
00:10:30.073 --> 00:10:31.715
<v SPEAKER_00>And there's some obvious problem with that,

207
00:10:31.755 --> 00:10:35.699
<v SPEAKER_00>which is that if two pieces of code run together that were not written to run together,

208
00:10:36.786 --> 00:10:37.286
<v SPEAKER_00> What happens?

209
00:10:37.707 --> 00:10:41.349
<v SPEAKER_00>Well, my code could grab some memory and write to some memory.

210
00:10:41.749 --> 00:10:43.971
<v SPEAKER_00>Your code could grab some memory and write to some memory.

211
00:10:44.411 --> 00:10:48.514
<v SPEAKER_00>We wouldn't have planned that that would actually lead to any sort of conflict, but it did.

212
00:10:50.135 --> 00:10:53.898
<v SPEAKER_00>We just stamp over each other's work, and that obviously will lead to problems.

213
00:10:56.059 --> 00:11:01.203
<v SPEAKER_00>Which means what this ends up requiring is that any code which would have looked

214
00:11:01.223 --> 00:11:01.683
<v SPEAKER_00>like this,

215
00:11:02.564 --> 00:11:04.005
<v SPEAKER_00>where you just grab some pointer,

216
00:11:04.385 --> 00:11:05.046
<v SPEAKER_00>start writing to it,

217
00:11:06.752 --> 00:11:11.235
<v SPEAKER_00> That has to turn into this, where every address, you don't know the addresses.

218
00:11:11.255 --> 00:11:12.615
<v SPEAKER_00>They're not resolved statically.

219
00:11:12.635 --> 00:11:16.977
<v SPEAKER_00>You have to go to some shared allocator layer and allocate it dynamically.

220
00:11:16.997 --> 00:11:18.818
<v SPEAKER_00>Now, you don't really care where the base address is.

221
00:11:18.838 --> 00:11:20.859
<v SPEAKER_00>You just care about how much space you have.

222
00:11:20.879 --> 00:11:24.881
<v SPEAKER_00>And the allocator has to care about that so that it doesn't give the same regions

223
00:11:24.921 --> 00:11:26.102
<v SPEAKER_00>of memory out to other people.

224
00:11:26.182 --> 00:11:32.385
<v SPEAKER_00>So that's the first example of memory allocation in this bottom up look at things.

225
00:11:34.198 --> 00:11:36.800
<v SPEAKER_00> And so far, it doesn't look that different.

226
00:11:37.360 --> 00:11:39.641
<v SPEAKER_00>Sure, people will be like, oh, I don't like the syntax or whatever.

227
00:11:40.222 --> 00:11:45.685
<v SPEAKER_00>But so far, it's not that much more complicated, maybe, than a scripting language.

228
00:11:45.825 --> 00:11:46.606
<v SPEAKER_00>You just grab x,

229
00:11:47.166 --> 00:11:48.507
<v SPEAKER_00>start writing some array,

230
00:11:48.867 --> 00:11:49.888
<v SPEAKER_00>start writing into the array,

231
00:11:50.168 --> 00:11:51.128
<v SPEAKER_00>and then you forget about x.

232
00:11:51.709 --> 00:11:52.890
<v SPEAKER_00>Like in a garbage collect language,

233
00:11:53.270 --> 00:11:54.691
<v SPEAKER_00>you can just kind of do that.

234
00:11:55.331 --> 00:11:56.752
<v SPEAKER_00>So what's the issue here?

235
00:11:56.772 --> 00:11:59.714
<v SPEAKER_00>Why is memory management considered so complicated?

236
00:12:00.802 --> 00:12:06.664
<v SPEAKER_00> Well, as it turns out, both address space and physical memory are not infinite.

237
00:12:07.024 --> 00:12:10.186
<v SPEAKER_00>You don't have infinite storage capacity on your computer.

238
00:12:11.086 --> 00:12:16.008
<v SPEAKER_00>And you can run out of either virtual address space or of physical memory.

239
00:12:16.068 --> 00:12:18.169
<v SPEAKER_00>The operating system might just kill your process.

240
00:12:21.130 --> 00:12:23.131
<v SPEAKER_00>Now, it's worth noticing that sometimes it doesn't matter.

241
00:12:23.531 --> 00:12:24.751
<v SPEAKER_00>So this is an email from

242
00:12:26.550 --> 00:12:28.912
<v SPEAKER_00> I've got the person named Kent Mitchell, I believe.

243
00:12:29.432 --> 00:12:29.993
<v SPEAKER_00>Kent Mitchell.

244
00:12:30.513 --> 00:12:31.134
<v SPEAKER_00>It was an email.

245
00:12:31.714 --> 00:12:33.496
<v SPEAKER_00>But I found this on Raymond Chen's blog.

246
00:12:34.156 --> 00:12:35.117
<v SPEAKER_00>And the title of this post,

247
00:12:35.157 --> 00:12:35.738
<v SPEAKER_00>if you can't read it,

248
00:12:35.838 --> 00:12:39.380
<v SPEAKER_00>is an amusing story about a practical use of the null garbage collector.

249
00:12:40.341 --> 00:12:42.743
<v SPEAKER_00>And what in the world is a null garbage collector?

250
00:12:42.783 --> 00:12:48.948
<v SPEAKER_00>Well, long story short, Kent Mitchell, who is a consultant, was working with a weapons firm.

251
00:12:49.989 --> 00:12:54.413
<v SPEAKER_00>And he was doing some analysis on this onboard missile software.

252
00:12:56.266 --> 00:12:58.168
<v SPEAKER_00>And he was a little confused because he was like,

253
00:12:58.188 --> 00:12:58.328
<v SPEAKER_00>look,

254
00:12:58.348 --> 00:13:00.729
<v SPEAKER_00>you guys have all these memory leaks on your computer.

255
00:13:00.749 --> 00:13:03.692
<v SPEAKER_00>You're allocating things and never getting rid of them, never reusing that memory.

256
00:13:04.432 --> 00:13:07.775
<v SPEAKER_00>And the chief software engineer was like, well, yeah, because why would we?

257
00:13:07.955 --> 00:13:14.100
<v SPEAKER_00>There's enough memory on board the missile to last.

258
00:13:14.320 --> 00:13:17.522
<v SPEAKER_00>If we leak this many bytes per second or whatever,

259
00:13:20.297 --> 00:13:23.438
<v SPEAKER_00> We put enough onboard memory to last the entire flight.

260
00:13:23.739 --> 00:13:26.120
<v SPEAKER_00>And at the end of the flight, there's no computer.

261
00:13:26.380 --> 00:13:26.940
<v SPEAKER_00>It doesn't matter.

262
00:13:27.080 --> 00:13:28.160
<v SPEAKER_00>It ceases to exist.

263
00:13:28.861 --> 00:13:32.362
<v SPEAKER_00>So that was a very practical thing.

264
00:13:32.462 --> 00:13:34.563
<v SPEAKER_00>It's like, no, we don't care about releasing things.

265
00:13:34.583 --> 00:13:35.824
<v SPEAKER_00>We're trying to hit a target.

266
00:13:38.474 --> 00:13:40.716
<v SPEAKER_00> So sometimes you can act like this.

267
00:13:41.737 --> 00:13:46.161
<v SPEAKER_00>Now remember, most of us don't write software for missiles.

268
00:13:47.142 --> 00:13:51.186
<v SPEAKER_00>But remember how I told you earlier that this address space deal,

269
00:13:51.926 --> 00:13:53.628
<v SPEAKER_00>that's all managed by the operating system.

270
00:13:53.668 --> 00:13:55.289
<v SPEAKER_00>How your address space translates

271
00:13:56.090 --> 00:13:59.593
<v SPEAKER_00> into the physical resources of the computer, that's managed by the operating system.

272
00:13:59.613 --> 00:14:02.716
<v SPEAKER_00>So when your program crashes or when your program naturally closes,

273
00:14:03.197 --> 00:14:06.380
<v SPEAKER_00>the operating system knows everything you had in memory and where.

274
00:14:06.900 --> 00:14:11.024
<v SPEAKER_00>So if you allocated all this memory and didn't free it, not an issue.

275
00:14:11.044 --> 00:14:12.866
<v SPEAKER_00>The operating system was already going to clean that up.

276
00:14:13.646 --> 00:14:15.548
<v SPEAKER_00>So that already happens.

277
00:14:16.109 --> 00:14:18.250
<v SPEAKER_00>And so what that basically means is

278
00:14:20.117 --> 00:14:24.801
<v SPEAKER_00> You can treat your program ending as its own little sort of null garbage collector.

279
00:14:24.821 --> 00:14:25.582
<v SPEAKER_00>That's number one.

280
00:14:26.723 --> 00:14:30.146
<v SPEAKER_00>But what if we're not in that situation?

281
00:14:30.166 --> 00:14:32.268
<v SPEAKER_00>Because obviously, that's not every situation.

282
00:14:32.709 --> 00:14:33.730
<v SPEAKER_00>You can't just leak forever.

283
00:14:35.071 --> 00:14:39.495
<v SPEAKER_00>And when that's true, this concept of the lifetime emerges.

284
00:14:39.515 --> 00:14:41.737
<v SPEAKER_00>You have some alloc, which is what I've introduced already.

285
00:14:42.665 --> 00:14:46.147
<v SPEAKER_00> And because you can't, if you stop accessing that memory, you don't need it anymore.

286
00:14:46.688 --> 00:14:48.729
<v SPEAKER_00>If you do, then you just run out of resources.

287
00:14:48.929 --> 00:14:50.510
<v SPEAKER_00>You've got to scale back your problem or something.

288
00:14:50.530 --> 00:14:52.371
<v SPEAKER_00>But generally, you can reuse things.

289
00:14:53.332 --> 00:14:58.255
<v SPEAKER_00>And so the alloc, one way to solve it would be to introduce a symmetric free.

290
00:14:58.516 --> 00:15:00.117
<v SPEAKER_00>So for every alloc, you have some release.

291
00:15:00.677 --> 00:15:04.139
<v SPEAKER_00>And then the time span between those things for any individual block of memory

292
00:15:04.159 --> 00:15:05.961
<v SPEAKER_00>could be considered a lifetime.

293
00:15:09.244 --> 00:15:13.167
<v SPEAKER_00>So an extreme usage rule would be every allocation you ever do,

294
00:15:14.008 --> 00:15:14.748
<v SPEAKER_00>you call alloc,

295
00:15:15.228 --> 00:15:17.490
<v SPEAKER_00>and then you just release it at the right time.

296
00:15:19.291 --> 00:15:22.713
<v SPEAKER_00>And so if you follow that rule to the extreme, you end up with code like this.

297
00:15:23.153 --> 00:15:27.436
<v SPEAKER_00>And every single possible thing in your program that could be dynamically allocated

298
00:15:27.456 --> 00:15:31.559
<v SPEAKER_00>that you can't statically know about ends up with this alloc and release.

299
00:15:31.839 --> 00:15:34.080
<v SPEAKER_00>You just get these pairs of functions that look like this.

300
00:15:36.567 --> 00:15:37.508
<v SPEAKER_00>Just as an aside,

301
00:15:38.048 --> 00:15:42.131
<v SPEAKER_00>this is all the stuff that garbage collection and automatic reference counting and RAII,

302
00:15:42.791 --> 00:15:45.413
<v SPEAKER_00>they're trying to automate code that looks like this.

303
00:15:48.255 --> 00:15:53.359
<v SPEAKER_00>But this rule taken to the extreme is where the complexity of memory management comes in.

304
00:15:53.819 --> 00:15:56.001
<v SPEAKER_00>Again, that's the problem that garbage collection is trying to solve.

305
00:15:56.381 --> 00:16:02.506
<v SPEAKER_00>You might think that when you adopt that pattern, you're sort of just having this timeline.

306
00:16:03.747 --> 00:16:05.668
<v SPEAKER_00> of various lifetimes.

307
00:16:05.908 --> 00:16:08.469
<v SPEAKER_00>And then you just alloc and release, and then everything's good.

308
00:16:08.930 --> 00:16:10.370
<v SPEAKER_00>And then time flows on as normal.

309
00:16:10.870 --> 00:16:13.292
<v SPEAKER_00>But this is not a totally complete picture,

310
00:16:13.332 --> 00:16:14.092
<v SPEAKER_00>because also,

311
00:16:14.712 --> 00:16:17.814
<v SPEAKER_00>each one of these lifetimes depends on other lifetimes.

312
00:16:18.294 --> 00:16:22.176
<v SPEAKER_00>And so what you get is this sort of web or graph of lifetimes that you constantly

313
00:16:22.236 --> 00:16:24.197
<v SPEAKER_00>have to upkeep as your program

314
00:16:25.477 --> 00:16:26.478
<v SPEAKER_00> continues to be developed.

315
00:16:26.518 --> 00:16:29.219
<v SPEAKER_00>This isn't something that you write all the allocs and frees once.

316
00:16:29.780 --> 00:16:34.122
<v SPEAKER_00>It's something like you have to worry about all of the allocs and frees occurring

317
00:16:34.162 --> 00:16:38.125
<v SPEAKER_00>at the appropriate times throughout the course of a project's lifetime.

318
00:16:40.792 --> 00:16:41.613
<v SPEAKER_00>So you can imagine,

319
00:16:42.353 --> 00:16:43.914
<v SPEAKER_00>in a case like a simple parser,

320
00:16:45.035 --> 00:16:45.935
<v SPEAKER_00>on the left-hand side,

321
00:16:46.095 --> 00:16:46.456
<v SPEAKER_00>A to B,

322
00:16:46.856 --> 00:16:47.556
<v SPEAKER_00>we start with text,

323
00:16:47.616 --> 00:16:49.257
<v SPEAKER_00>produce a tree of nodes or something like that,

324
00:16:49.277 --> 00:16:50.278
<v SPEAKER_00>like an abstract syntax tree.

325
00:16:51.238 --> 00:16:52.579
<v SPEAKER_00>You have some parsing code path.

326
00:16:53.160 --> 00:16:54.661
<v SPEAKER_00>It'll produce a structure that looks like this.

327
00:16:54.741 --> 00:16:55.861
<v SPEAKER_00>You've got some node struct.

328
00:16:56.442 --> 00:17:03.386
<v SPEAKER_00>And then visualizing the structure on the right-hand side looks like that.

329
00:17:05.427 --> 00:17:08.428
<v SPEAKER_00>And every single one of those nodes that you didn't know you needed initially,

330
00:17:08.648 --> 00:17:10.169
<v SPEAKER_00>in other words,

331
00:17:10.189 --> 00:17:12.109
<v SPEAKER_00>you needed to dynamically allocate for,

332
00:17:13.750 --> 00:17:15.070
<v SPEAKER_00>every single time you call alloc,

333
00:17:15.090 --> 00:17:20.472
<v SPEAKER_00>you've introduced some hidden constraint to your code where release has to also be

334
00:17:20.512 --> 00:17:22.513
<v SPEAKER_00>called at some point.

335
00:17:24.173 --> 00:17:26.194
<v SPEAKER_00>And this sort of requires constant maintenance.

336
00:17:26.214 --> 00:17:28.135
<v SPEAKER_00>You have to write all of those free encode paths.

337
00:17:28.155 --> 00:17:30.736
<v SPEAKER_00>You have to make sure they don't happen at inopportune times.

338
00:17:31.701 --> 00:17:33.022
<v SPEAKER_00>And if you fail to do that,

339
00:17:33.943 --> 00:17:37.245
<v SPEAKER_00>then you'll run into a bunch of correctness issues that are very subtle and

340
00:17:37.265 --> 00:17:37.905
<v SPEAKER_00>difficult to catch.

341
00:17:39.299 --> 00:17:41.520
<v SPEAKER_00>Some of the problems you'll run into are sort of the ones that,

342
00:17:41.621 --> 00:17:44.282
<v SPEAKER_00>if you've ever spoken to a Rust programmer,

343
00:17:46.623 --> 00:17:48.544
<v SPEAKER_00>you maybe only talked about the issues with them,

344
00:17:49.245 --> 00:17:51.186
<v SPEAKER_00>because it's kind of what they bring up.

345
00:17:51.646 --> 00:17:53.567
<v SPEAKER_00>And they're things like, first of all, you've got the memory leak.

346
00:17:53.587 --> 00:17:59.831
<v SPEAKER_00>You've allocated something, and you've stopped accessing it, and it never is reused.

347
00:17:59.871 --> 00:18:01.151
<v SPEAKER_00>It just lives on forever.

348
00:18:01.452 --> 00:18:02.012
<v SPEAKER_00>You just have a leak.

349
00:18:04.224 --> 00:18:05.465
<v SPEAKER_00>You can also have a use after free,

350
00:18:06.445 --> 00:18:07.986
<v SPEAKER_00>where you did remember to release something,

351
00:18:08.367 --> 00:18:10.628
<v SPEAKER_00>other code was not aware of this fact for some reason,

352
00:18:11.368 --> 00:18:14.010
<v SPEAKER_00>and it tried to rewrite to that pointer.

353
00:18:14.630 --> 00:18:18.613
<v SPEAKER_00>And you can imagine how that gets especially bad if someone else allocated that

354
00:18:18.653 --> 00:18:20.594
<v SPEAKER_00>same block of memory that you're trying to reuse,

355
00:18:23.316 --> 00:18:27.538
<v SPEAKER_00>but some other code path thinks it's this still allocated thing through a dangling pointer,

356
00:18:27.578 --> 00:18:27.939
<v SPEAKER_00>basically.

357
00:18:29.096 --> 00:18:32.299
<v SPEAKER_00> And then there's things like, there's more subtle versions of that, right?

358
00:18:32.319 --> 00:18:36.803
<v SPEAKER_00>You have the double free case where it's like, oh, A was allocated.

359
00:18:36.863 --> 00:18:38.084
<v SPEAKER_00>Someone remembered to release it.

360
00:18:39.805 --> 00:18:45.270
<v SPEAKER_00>Some other codepath thought it had the responsibility of releasing A, and so it did the same thing later.

361
00:18:45.350 --> 00:18:50.033
<v SPEAKER_00>But before that happened, someone else allocated the same block, and so you get this double free kind of

362
00:18:51.821 --> 00:18:55.984
<v SPEAKER_00>thing where the orange part of this was allocated by someone else and they expect

363
00:18:56.004 --> 00:18:56.805
<v SPEAKER_00>that memory to be around,

364
00:18:56.825 --> 00:18:59.387
<v SPEAKER_00>but someone else just went and freed it underneath them.

365
00:19:03.319 --> 00:19:04.540
<v SPEAKER_00> It's kind of a big issue.

366
00:19:05.480 --> 00:19:09.662
<v SPEAKER_00>Other things occur with this kind of approach to memory management.

367
00:19:09.782 --> 00:19:15.386
<v SPEAKER_00>Over time, your available memory store can become very corrupt, not corrupted, fragmented.

368
00:19:16.086 --> 00:19:19.047
<v SPEAKER_00>You start with maybe just filling the available space you have.

369
00:19:19.708 --> 00:19:24.190
<v SPEAKER_00>And then you might free individual small chunks of that memory such that you have a

370
00:19:24.210 --> 00:19:25.331
<v SPEAKER_00>bunch of space available.

371
00:19:27.492 --> 00:19:28.213
<v SPEAKER_00> contiguous.

372
00:19:28.233 --> 00:19:32.877
<v SPEAKER_00>You have all these little chunks of memory that you can't fill because they're too

373
00:19:32.937 --> 00:19:34.779
<v SPEAKER_00>small to be useful for a bunch of cases.

374
00:19:38.823 --> 00:19:39.083
<v SPEAKER_00>And so,

375
00:19:39.103 --> 00:19:40.384
<v SPEAKER_00>outlock and release,

376
00:19:40.404 --> 00:19:47.111
<v SPEAKER_00>that concept is implemented in the C standard library through these two calls,

377
00:19:47.171 --> 00:19:47.711
<v SPEAKER_00>malloc and free.

378
00:19:51.618 --> 00:19:57.083
<v SPEAKER_00>Keep in mind that the possible implications of malloc as a sort of interface,

379
00:19:57.843 --> 00:20:02.607
<v SPEAKER_00>being able to alloc and release at whatever time works for you,

380
00:20:03.208 --> 00:20:07.131
<v SPEAKER_00>means that in a case like this where I'm allocating these four blocks of memory,

381
00:20:07.571 --> 00:20:10.994
<v SPEAKER_00>I can sort of allocate and free in sort of a variety of orders.

382
00:20:11.014 --> 00:20:15.238
<v SPEAKER_00>It has to be ready for any possible combination of allocs and frees that I can throw at it.

383
00:20:16.715 --> 00:20:20.359
<v SPEAKER_00> And what that happens to lead to is a lot of implementation complexity.

384
00:20:20.439 --> 00:20:23.762
<v SPEAKER_00>I went and looked at glibc's malloc implementation.

385
00:20:23.782 --> 00:20:26.605
<v SPEAKER_00>I mean, you can't even read it.

386
00:20:26.625 --> 00:20:28.126
<v SPEAKER_00>But I didn't put all of it on the slide.

387
00:20:29.127 --> 00:20:32.551
<v SPEAKER_00>But it's like 5,600 lines of code for this malloc implementation.

388
00:20:32.571 --> 00:20:34.012
<v SPEAKER_00>Now, obviously, it's tightly optimized.

389
00:20:34.032 --> 00:20:35.634
<v SPEAKER_00>They've done a bunch of things for it.

390
00:20:35.854 --> 00:20:37.596
<v SPEAKER_00>There are other malloc implementations that are bigger.

391
00:20:39.960 --> 00:20:41.941
<v SPEAKER_00> But that's a lot of code.

392
00:20:42.121 --> 00:20:43.981
<v SPEAKER_00>I'm not here to tell you how to write your own malloc,

393
00:20:44.001 --> 00:20:45.362
<v SPEAKER_00>because everyone knows that,

394
00:20:45.902 --> 00:20:47.202
<v SPEAKER_00>unless you're really interested in this kind of thing,

395
00:20:47.602 --> 00:20:48.043
<v SPEAKER_00>you'll be like,

396
00:20:48.063 --> 00:20:49.903
<v SPEAKER_00>I don't really want to go and do that.

397
00:20:49.943 --> 00:20:51.284
<v SPEAKER_00>That's not what you do.

398
00:20:51.344 --> 00:20:52.924
<v SPEAKER_00>I'd much rather use garbage collection.

399
00:20:55.645 --> 00:20:58.946
<v SPEAKER_00>This also leads to a problem.

400
00:20:58.966 --> 00:21:04.048
<v SPEAKER_00>The interface of malloc leads to this issue of contention between multiple threads.

401
00:21:04.168 --> 00:21:06.388
<v SPEAKER_00>You have two different threads accessing this global allocator.

402
00:21:09.192 --> 00:21:14.656
<v SPEAKER_00> you know, that leads to advice like don't dynamically allocate in a hot loop, right?

403
00:21:14.696 --> 00:21:15.837
<v SPEAKER_00>Because why would you?

404
00:21:15.897 --> 00:21:17.738
<v SPEAKER_00>You're causing contention between threads.

405
00:21:18.458 --> 00:21:20.119
<v SPEAKER_00>Just don't do it, right?

406
00:21:22.661 --> 00:21:24.242
<v SPEAKER_00>So, quick question.

407
00:21:25.423 --> 00:21:26.824
<v SPEAKER_00>Have you written code this way before?

408
00:21:26.884 --> 00:21:28.805
<v SPEAKER_00>Just, like, raise your hand if you want to answer.

409
00:21:28.945 --> 00:21:30.507
<v SPEAKER_00>And what issues did you encounter?

410
00:21:32.328 --> 00:21:34.289
<v SPEAKER_00>Anybody want to say anything about that?

411
00:21:35.010 --> 00:21:35.230
<v SPEAKER_00>Right here.

412
00:21:35.250 --> 00:21:35.830
<v SPEAKER_02>I actually run out of time.

413
00:21:45.407 --> 00:21:49.931
<v SPEAKER_00> Yeah.

414
00:21:51.652 --> 00:21:52.032
<v SPEAKER_00>Oh, I see.

415
00:21:53.293 --> 00:21:54.534
<v SPEAKER_00>So in your case,

416
00:21:54.634 --> 00:21:58.397
<v SPEAKER_00>most of the time was spent in the allocator just because of the wide scalability

417
00:21:58.417 --> 00:21:59.478
<v SPEAKER_00>that you had in your problem?

418
00:21:59.578 --> 00:22:05.202
<v SPEAKER_02>Right, right, right.

419
00:22:05.342 --> 00:22:05.703
<v SPEAKER_02>OK, sure.

420
00:22:16.038 --> 00:22:16.278
 Right here.

421
00:22:16.538 --> 00:22:16.938
Right.

422
00:22:16.978 --> 00:22:17.178
Sure.

423
00:22:17.238 --> 00:22:18.539
Yeah, yeah, for sure.

424
00:22:18.679 --> 00:22:21.819
Anyone else want to say anything?

425
00:22:21.899 --> 00:22:22.940
<v SPEAKER_02>Okay, sure.

426
00:22:23.220 --> 00:22:24.420
<v SPEAKER_02>Yeah, back there.

427
00:22:43.851 --> 00:22:44.152
 Yeah.

428
00:22:52.898 --> 00:22:53.338
<v SPEAKER_00> Yeah, for sure.

429
00:22:53.418 --> 00:22:55.919
<v SPEAKER_00>And that example I used, let me go back a little bit.

430
00:22:56.479 --> 00:23:00.441
<v SPEAKER_00>This example right here of the tree, this is kind of one of the easiest cases.

431
00:23:00.741 --> 00:23:02.862
<v SPEAKER_00>Because everything is clearly scoped.

432
00:23:03.422 --> 00:23:08.744
<v SPEAKER_00>When you free the top of, if you imagine freeing this structure, you have to do a little bit of things.

433
00:23:08.764 --> 00:23:09.765
<v SPEAKER_00>You have to free the node.

434
00:23:09.805 --> 00:23:12.406
<v SPEAKER_00>But before you free, you grab the children pointers.

435
00:23:12.446 --> 00:23:14.327
<v SPEAKER_00>So then you follow those and so on.

436
00:23:14.347 --> 00:23:15.447
<v SPEAKER_00>But for the most part,

437
00:23:15.647 --> 00:23:18.888
<v SPEAKER_00>there's a single tree walk that you can do that's well-defined and will free the

438
00:23:18.908 --> 00:23:19.309
<v SPEAKER_00>entire thing.

439
00:23:19.329 --> 00:23:22.670
<v SPEAKER_00>But it gets way more complicated to actually release structures if it's like a graph.

440
00:23:22.870 --> 00:23:25.312
<v SPEAKER_00> or something.

441
00:23:25.412 --> 00:23:26.553
<v SPEAKER_00>It becomes kind of a nightmare.

442
00:23:27.454 --> 00:23:32.339
<v SPEAKER_00>And it's entirely stuff that you didn't want to think about when you were worrying about your problem.

443
00:23:36.322 --> 00:23:40.326
<v SPEAKER_00>So point being,

444
00:23:41.388 --> 00:23:48.095
<v SPEAKER_00> Maybe this whole make a giant soup of lifetimes, maybe that was just kind of the wrong approach.

445
00:23:48.135 --> 00:23:50.938
<v SPEAKER_00>Maybe that was the wrong problem to solve.

446
00:23:50.978 --> 00:23:54.202
<v SPEAKER_00>Maybe that was a mess that we didn't have to get ourselves into.

447
00:23:54.282 --> 00:23:57.785
<v SPEAKER_00>And maybe the alternative is to treat things in groups.

448
00:23:58.706 --> 00:24:01.069
<v SPEAKER_00>This was also mentioned in the Mike Acton talk.

449
00:24:01.349 --> 00:24:02.430
<v SPEAKER_00>Where there's one, there's many.

450
00:24:03.513 --> 00:24:08.262
<v SPEAKER_00> And you can approach the problem from bundling lifetimes as much as possible.

451
00:24:08.302 --> 00:24:12.911
<v SPEAKER_00>So that graph of complicated lifetimes becomes very small and manageable.

452
00:24:15.106 --> 00:24:16.607
<v SPEAKER_00>So we have an example of this already,

453
00:24:16.748 --> 00:24:20.531
<v SPEAKER_00>which this is the other memory management thing that most people don't talk about

454
00:24:21.552 --> 00:24:23.394
<v SPEAKER_00>when they talk about the problems of memory management in C.

455
00:24:23.834 --> 00:24:25.255
<v SPEAKER_00>There are issues you can screw it up.

456
00:24:25.616 --> 00:24:26.997
<v SPEAKER_00>In fact, I screwed it up.

457
00:24:27.057 --> 00:24:30.080
<v SPEAKER_00>And you'll see an example of this later in the conference.

458
00:24:31.842 --> 00:24:33.243
<v SPEAKER_00>I wrote a bug related to this.

459
00:24:33.323 --> 00:24:35.625
<v SPEAKER_00>But point is, most people don't think about the stack.

460
00:24:35.665 --> 00:24:38.868
<v SPEAKER_00>They're like, oh, the memory cleans itself up for you.

461
00:24:38.908 --> 00:24:40.269
<v SPEAKER_00>It just sort of handles itself.

462
00:24:41.170 --> 00:24:43.711
<v SPEAKER_00>And if we look at what the stack is actually doing,

463
00:24:43.791 --> 00:24:46.232
<v SPEAKER_00>it has a different sort of interface to this whole problem.

464
00:24:46.292 --> 00:24:50.853
<v SPEAKER_00>It's like every local variable you declare is like an alloc.

465
00:24:51.633 --> 00:24:54.534
<v SPEAKER_00>And then the closing brace is sort of like your way of saying,

466
00:24:54.954 --> 00:24:56.855
<v SPEAKER_00>release everything that I declared in this block.

467
00:24:59.836 --> 00:25:03.517
<v SPEAKER_00>And so lifetime becomes not a property of an individual allocation.

468
00:25:03.557 --> 00:25:06.938
<v SPEAKER_00>It becomes a property of the scope.

469
00:25:07.118 --> 00:25:09.939
<v SPEAKER_00>The scope itself is sort of correlated one to one with lifetimes.

470
00:25:11.756 --> 00:25:13.217
<v SPEAKER_00> And it mostly just works.

471
00:25:13.277 --> 00:25:14.417
<v SPEAKER_00>Most people get this right away.

472
00:25:14.437 --> 00:25:16.078
<v SPEAKER_00>You don't have to think about it very often.

473
00:25:16.118 --> 00:25:18.519
<v SPEAKER_00>There's some issues where you can return a pointer to something.

474
00:25:18.939 --> 00:25:20.820
<v SPEAKER_00>I literally did this.

475
00:25:20.900 --> 00:25:25.962
<v SPEAKER_00>But for the most part, it's easy to diagnose issues when they happen.

476
00:25:26.342 --> 00:25:29.723
<v SPEAKER_00>And it's also easy to not make those mistakes in the first place.

477
00:25:31.844 --> 00:25:34.965
<v SPEAKER_00>And so bundling all of these allocations together,

478
00:25:37.873 --> 00:25:39.674
<v SPEAKER_00> is very, very simple.

479
00:25:39.714 --> 00:25:43.817
<v SPEAKER_00>It leads to a very simple implementation if you look at how a stack is actually implemented,

480
00:25:43.917 --> 00:25:48.280
<v SPEAKER_00>or just like the regular stack that you're used to working with in a language like C.

481
00:25:49.240 --> 00:25:50.521
<v SPEAKER_00>If I declare a variable,

482
00:25:50.901 --> 00:25:52.082
<v SPEAKER_00>like 256 U32s,

483
00:25:54.144 --> 00:25:55.544
<v SPEAKER_00>basically there's some stack pointer.

484
00:25:56.205 --> 00:26:00.728
<v SPEAKER_00>It uses that pointer for whatever variable I declare.

485
00:26:00.748 --> 00:26:02.929
<v SPEAKER_00>A lot of this is statically determined.

486
00:26:05.592 --> 00:26:07.113
<v SPEAKER_00> And then it just bumps the stack pointer.

487
00:26:07.133 --> 00:26:08.214
<v SPEAKER_00>It just bumps forward.

488
00:26:08.614 --> 00:26:13.838
<v SPEAKER_00>And so you can imagine the stack has this initial reservation with some capacity.

489
00:26:14.418 --> 00:26:16.119
<v SPEAKER_00>And then the pointer starts at the beginning.

490
00:26:16.139 --> 00:26:18.141
<v SPEAKER_00>And then every time you need to push, you just push onto it.

491
00:26:21.923 --> 00:26:24.485
<v SPEAKER_00>And so remember that in setting up the stack,

492
00:26:26.511 --> 00:26:27.791
<v SPEAKER_00> None of this goes away.

493
00:26:28.171 --> 00:26:32.632
<v SPEAKER_00>The operating system did have to use a complex allocator to reserve the correct

494
00:26:33.112 --> 00:26:35.733
<v SPEAKER_00>address spaces and set up the stacks.

495
00:26:36.033 --> 00:26:39.134
<v SPEAKER_00>But it pays the cost once per thread, not once per alloc.

496
00:26:40.454 --> 00:26:43.434
<v SPEAKER_00>So why pay the complexity and the performance and all that stuff?

497
00:26:43.694 --> 00:26:45.675
<v SPEAKER_00>Why pay all those costs everywhere?

498
00:26:49.496 --> 00:26:51.916
<v SPEAKER_00>So imagine this example.

499
00:26:52.516 --> 00:26:53.576
<v SPEAKER_00>Foo calls into bar.

500
00:26:57.768 --> 00:27:04.330
<v SPEAKER_00> Upon each scope exit, you can sort of think of it as your own little null garbage collector.

501
00:27:04.410 --> 00:27:05.951
<v SPEAKER_00>It's like the missile explodes.

502
00:27:05.991 --> 00:27:06.871
<v SPEAKER_00>Your function's gone.

503
00:27:07.412 --> 00:27:08.652
<v SPEAKER_00>Everything is popped off the stack.

504
00:27:10.333 --> 00:27:12.413
<v SPEAKER_00>And it'll be reused for something else.

505
00:27:12.453 --> 00:27:16.315
<v SPEAKER_00>So you can sort of treat that as almost like a mini little null garbage collector.

506
00:27:17.975 --> 00:27:19.656
<v SPEAKER_00>So the stack's pretty amazing.

507
00:27:20.676 --> 00:27:24.198
<v SPEAKER_00>But why is anything other than the stack necessary?

508
00:27:24.258 --> 00:27:25.978
<v SPEAKER_00>We should have just done everything on the stack.

509
00:27:28.052 --> 00:27:30.094
<v SPEAKER_00> But why is that not true?

510
00:27:30.674 --> 00:27:32.796
<v SPEAKER_00>Most will say limited size.

511
00:27:32.876 --> 00:27:34.657
<v SPEAKER_00>That's not really true today.

512
00:27:36.338 --> 00:27:37.880
<v SPEAKER_00>So then why use anything else?

513
00:27:37.940 --> 00:27:38.860
<v SPEAKER_00>What's the deal?

514
00:27:39.441 --> 00:27:42.303
<v SPEAKER_00>Well, the problems start with this kind of pattern.

515
00:27:43.144 --> 00:27:47.727
<v SPEAKER_00>If I am in foo and I want to call into bar that wants to allocate something for me,

516
00:27:48.388 --> 00:27:54.993
<v SPEAKER_00>I can't allocate stuff in bar because bar can't allocate stuff.

517
00:27:55.033 --> 00:27:57.314
<v SPEAKER_00>It only has a mechanism to push higher.

518
00:27:59.977 --> 00:28:01.879
<v SPEAKER_00>So if it allocates inside of its lifetime,

519
00:28:01.919 --> 00:28:03.400
<v SPEAKER_00>by the time it returns to foo,

520
00:28:04.621 --> 00:28:06.003
<v SPEAKER_00>that allocation is going to be gone.

521
00:28:06.203 --> 00:28:12.009
<v SPEAKER_00>This is the lifetime I wanted for stuff, but that can't be facilitated by calling into bar.

522
00:28:14.351 --> 00:28:17.134
<v SPEAKER_00>So there's a workaround, and you'll see a lot of code that does this.

523
00:28:17.614 --> 00:28:22.239
<v SPEAKER_00>You allocate stuff at the call side, and then pass in a pointer and say, bar, please initialize this.

524
00:28:23.305 --> 00:28:26.006
<v SPEAKER_00> And that can work, but it stops working pretty quickly.

525
00:28:26.066 --> 00:28:27.707
<v SPEAKER_00>Remember this tree structure I had earlier.

526
00:28:28.287 --> 00:28:30.168
<v SPEAKER_00>You want to allocate something complicated like this,

527
00:28:30.208 --> 00:28:32.589
<v SPEAKER_00>like a big complicated graph or tree or something like that.

528
00:28:33.949 --> 00:28:35.830
<v SPEAKER_00>And as it just turns out,

529
00:28:36.710 --> 00:28:38.231
<v SPEAKER_00>initializing code,

530
00:28:38.311 --> 00:28:40.011
<v SPEAKER_00>like code that knows how to initialize a structure,

531
00:28:40.752 --> 00:28:43.813
<v SPEAKER_00>can often be the code that also knows how to allocate that structure.

532
00:28:47.218 --> 00:28:53.625
<v SPEAKER_00> So sometimes there's this web of lifetimes that you end up with.

533
00:28:53.665 --> 00:28:55.868
<v SPEAKER_00>And sometimes that's the correct thing for the problem.

534
00:28:55.908 --> 00:28:59.992
<v SPEAKER_00>It's like you can't just get away with a single stack that

535
00:29:01.514 --> 00:29:07.378
<v SPEAKER_00> You can imagine trying to pull all of these things into the correct stack position, if you will.

536
00:29:07.899 --> 00:29:10.000
<v SPEAKER_00>But it's coupled in with your call stack.

537
00:29:10.721 --> 00:29:12.082
<v SPEAKER_00>It just doesn't really work that well.

538
00:29:13.042 --> 00:29:16.425
<v SPEAKER_00>You can imagine a game level in a main loop.

539
00:29:17.626 --> 00:29:18.486
<v SPEAKER_00>You can imagine wanting to,

540
00:29:18.506 --> 00:29:18.687
<v SPEAKER_00>like,

541
00:29:19.447 --> 00:29:20.288
<v SPEAKER_00>missile explodes,

542
00:29:20.608 --> 00:29:22.689
<v SPEAKER_00>think about a game level when you want to load a new one.

543
00:29:24.091 --> 00:29:26.976
<v SPEAKER_00> But it's like the main loop is implemented in a call frame.

544
00:29:26.996 --> 00:29:28.999
<v SPEAKER_00>You're not going to pop out of the main loop and go back.

545
00:29:29.079 --> 00:29:31.143
<v SPEAKER_00>What really is going on there?

546
00:29:31.824 --> 00:29:34.709
<v SPEAKER_00>That wouldn't work with a stack situation.

547
00:29:37.283 --> 00:29:37.903
<v SPEAKER_00> So quick question.

548
00:29:38.344 --> 00:29:41.285
<v SPEAKER_00>What are other reasons you've just preferred not to use the stack?

549
00:29:41.485 --> 00:29:45.927
<v SPEAKER_00>Is there any time you've been thinking about trying to allocate some stuff,

550
00:29:46.947 --> 00:29:48.088
<v SPEAKER_00>and you've just been like,

551
00:29:48.108 --> 00:29:49.409
<v SPEAKER_00>the stack's not suitable for this problem?

552
00:29:49.449 --> 00:29:52.290
<v SPEAKER_00>If you thought it through, what was the reason why?

553
00:29:52.610 --> 00:29:54.871
<v SPEAKER_00>Any show of hands or anything?

554
00:29:55.931 --> 00:29:56.171
<v SPEAKER_00>Right here.

555
00:30:04.335 --> 00:30:04.895
<v SPEAKER_00>Sure, yeah.

556
00:30:05.456 --> 00:30:06.396
<v SPEAKER_00>You have recursion right there.

557
00:30:08.789 --> 00:30:09.489
<v SPEAKER_00> Yeah, yeah.

558
00:30:09.529 --> 00:30:15.211
<v SPEAKER_00>So like I said earlier, the stack, in practice, you can configure it such that it has much larger limits.

559
00:30:16.552 --> 00:30:20.093
<v SPEAKER_00>And it doesn't need to pre-commit all the memory.

560
00:30:20.133 --> 00:30:23.455
<v SPEAKER_00>But that is like a lot of code is written without a summary.

561
00:30:23.475 --> 00:30:25.735
<v SPEAKER_00>It doesn't want to change the stack size or something like that.

562
00:30:25.795 --> 00:30:26.776
<v SPEAKER_00>So anyone else?

563
00:30:27.096 --> 00:30:27.296
<v SPEAKER_00>Right here?

564
00:30:27.316 --> 00:30:31.177
<v SPEAKER_00>Data that will be shared between threads?

565
00:30:31.197 --> 00:30:31.778
<v SPEAKER_00>Yeah, yeah, yeah, sure.

566
00:30:31.978 --> 00:30:35.079
<v SPEAKER_00>Yeah, cross-thread data right there.

567
00:30:38.508 --> 00:30:39.208
<v SPEAKER_00> Like growable memory.

568
00:30:39.228 --> 00:30:41.569
<v SPEAKER_00>You don't want to assume a fixed size cap or something like that.

569
00:30:43.550 --> 00:30:43.930
<v SPEAKER_00>Anyone else?

570
00:30:44.331 --> 00:30:44.651
<v SPEAKER_00>Are we good?

571
00:30:46.211 --> 00:30:46.392
<v SPEAKER_00>OK.

572
00:30:47.632 --> 00:30:51.154
<v SPEAKER_00>So obviously, one stack has a bunch of limits.

573
00:30:52.294 --> 00:30:52.894
<v SPEAKER_00>It's weird.

574
00:30:52.914 --> 00:30:56.216
<v SPEAKER_00>The stack just seemed perfect, but we just discovered it has all these issues.

575
00:30:56.756 --> 00:30:58.377
<v SPEAKER_00>But what if you add n stacks?

576
00:30:58.457 --> 00:31:00.738
<v SPEAKER_00>What if you could just talk about n of them?

577
00:31:02.538 --> 00:31:05.800
<v SPEAKER_00> And nothing is stopping us from writing a concept like that.

578
00:31:05.940 --> 00:31:07.221
<v SPEAKER_00>And that's the whole idea.

579
00:31:07.461 --> 00:31:12.744
<v SPEAKER_00>That's the first sort of technique to know from this talk is this arena allocator thing.

580
00:31:13.264 --> 00:31:18.508
<v SPEAKER_00>And an arena is kind of just like one stack that you name and can refer to by name.

581
00:31:19.108 --> 00:31:24.451
<v SPEAKER_00>And one arena is just sort of like it's the entity that corresponds to one tree of lifetimes.

582
00:31:25.211 --> 00:31:27.033
<v SPEAKER_00>You sort of just refer to an arena.

583
00:31:29.278 --> 00:31:34.060
<v SPEAKER_00> And one thing it refers to is the tree of lifetimes.

584
00:31:34.740 --> 00:31:37.401
<v SPEAKER_00>So the arena lifetime begins upon arena alloc.

585
00:31:37.961 --> 00:31:42.222
<v SPEAKER_00>And then it ends when you release the whole arena, just jettison the whole thing away.

586
00:31:42.462 --> 00:31:45.543
<v SPEAKER_00>Or you can imagine clearing the arena too,

587
00:31:45.703 --> 00:31:49.624
<v SPEAKER_00>if you want to reuse it across multiple phases or something like that.

588
00:31:50.624 --> 00:31:51.845
<v SPEAKER_00>It can also intermediately pop.

589
00:31:52.125 --> 00:31:53.125
<v SPEAKER_00>You could push onto an arena.

590
00:31:53.925 --> 00:31:56.586
<v SPEAKER_00>You could also pop off the arena, but without clearing the whole thing.

591
00:31:58.905 --> 00:31:59.486
<v SPEAKER_00>And so now,

592
00:31:59.766 --> 00:32:03.050
<v SPEAKER_00>if we go back to that example where foo wants to call into bar and it wants bar to

593
00:32:03.130 --> 00:32:04.172
<v SPEAKER_00>allocate something for foo,

594
00:32:04.852 --> 00:32:06.374
<v SPEAKER_00>it can just pass in the arena and say,

595
00:32:06.474 --> 00:32:07.476
<v SPEAKER_00>I want the allocation here.

596
00:32:09.093 --> 00:32:10.574
<v SPEAKER_00> And that works for everything.

597
00:32:10.774 --> 00:32:14.556
<v SPEAKER_00>It works for if stuff happens to be a very simple allocation.

598
00:32:14.976 --> 00:32:16.217
<v SPEAKER_00>It works if it's a linked list.

599
00:32:16.737 --> 00:32:18.878
<v SPEAKER_00>It works if it's a big array.

600
00:32:19.199 --> 00:32:20.719
<v SPEAKER_00>It works if it's a complicated tree.

601
00:32:21.540 --> 00:32:24.962
<v SPEAKER_00>You just pass in the arena, and then it's like, bar knows how to allocate.

602
00:32:25.062 --> 00:32:28.844
<v SPEAKER_00>It doesn't have to push onto its call stack, but it can push onto the past arena.

603
00:32:31.072 --> 00:32:32.313
<v SPEAKER_00>And so our picture,

604
00:32:32.453 --> 00:32:34.354
<v SPEAKER_00>if we adopt that practice,

605
00:32:34.735 --> 00:32:39.118
<v SPEAKER_00>our picture of A transforms into B gets one little extra detail when we actually

606
00:32:39.178 --> 00:32:40.659
<v SPEAKER_00>implement a transform.

607
00:32:40.699 --> 00:32:41.880
<v SPEAKER_00>We have the result,

608
00:32:41.940 --> 00:32:42.440
<v SPEAKER_00>which is B.

609
00:32:42.780 --> 00:32:43.421
<v SPEAKER_00>We have the input,

610
00:32:43.441 --> 00:32:43.861
<v SPEAKER_00>which is A.

611
00:32:43.881 --> 00:32:46.603
<v SPEAKER_00>And then we have this extra lifetime parameter,

612
00:32:46.763 --> 00:32:47.364
<v SPEAKER_00>where you say,

613
00:32:48.985 --> 00:32:51.427
<v SPEAKER_00>B from A requires some sort of allocation.

614
00:32:51.447 --> 00:32:52.567
<v SPEAKER_00>It requires physical resources.

615
00:32:52.868 --> 00:32:54.649
<v SPEAKER_00>So here's where I want you to put those physical resources.

616
00:32:56.937 --> 00:33:04.660
<v SPEAKER_00> And so arenas, if you use them as this named concept, you can use them in a variety of circumstances.

617
00:33:05.080 --> 00:33:08.702
<v SPEAKER_00>Because you can construct them as referring to a lifetime,

618
00:33:08.742 --> 00:33:10.562
<v SPEAKER_00>you can control the bounds of that lifetime,

619
00:33:11.003 --> 00:33:11.723
<v SPEAKER_00>the properties of it.

620
00:33:12.323 --> 00:33:14.144
<v SPEAKER_00>And so you can use it for a number of different circumstances.

621
00:33:14.164 --> 00:33:15.925
<v SPEAKER_00>You can have frame arenas.

622
00:33:15.945 --> 00:33:17.745
<v SPEAKER_00>This is a very common example.

623
00:33:19.126 --> 00:33:22.167
<v SPEAKER_00>You can have a per request arena, if you're writing a web server or something like that.

624
00:33:22.987 --> 00:33:24.268
<v SPEAKER_00>You can also just have a permanent arena.

625
00:33:26.466 --> 00:33:27.967
<v SPEAKER_00> which just never resets.

626
00:33:28.007 --> 00:33:28.788
<v SPEAKER_00>You just never free it.

627
00:33:29.728 --> 00:33:32.250
<v SPEAKER_00>And you'll notice that at each of these call sites,

628
00:33:32.270 --> 00:33:33.671
<v SPEAKER_00>like where I'm grabbing B from A,

629
00:33:35.933 --> 00:33:40.156
<v SPEAKER_00>I've already declared where and how this thing is going to be freed just by passing

630
00:33:40.176 --> 00:33:41.076
<v SPEAKER_00>the associated arena,

631
00:33:41.096 --> 00:33:41.557
<v SPEAKER_00>right?

632
00:33:43.806 --> 00:33:45.807
<v SPEAKER_00> And this leads to other benefits too, right?

633
00:33:45.887 --> 00:33:50.349
<v SPEAKER_00>Remember how a single global allocator didn't play well with multiple threads.

634
00:33:50.549 --> 00:33:55.612
<v SPEAKER_00>They're going to be fighting over the actual implementation of the global allocator.

635
00:33:56.432 --> 00:33:58.933
<v SPEAKER_00>With arenas, you can dedicate arenas.

636
00:33:59.274 --> 00:34:03.276
<v SPEAKER_00>You can dedicate, OK, is that for me?

637
00:34:03.296 --> 00:34:07.117
<v SPEAKER_00>I think I'm OK.

638
00:34:10.779 --> 00:34:12.240
<v SPEAKER_00>But with arenas, you can have, you

639
00:34:13.530 --> 00:34:15.674
<v SPEAKER_00> you can just dedicate arenas to specific threads.

640
00:34:15.874 --> 00:34:20.181
<v SPEAKER_00>And they can just never touch the allocator of a different thread.

641
00:34:20.542 --> 00:34:27.313
<v SPEAKER_00>They can push at will without ever having to be worried about having to fight between multiple threads.

642
00:34:29.246 --> 00:34:32.288
<v SPEAKER_00> And so now, what happens if an arena runs out of room?

643
00:34:32.308 --> 00:34:34.109
<v SPEAKER_00>The same thing happened with the stack.

644
00:34:34.529 --> 00:34:36.350
<v SPEAKER_00>You can have stack overflows, for example.

645
00:34:37.770 --> 00:34:40.952
<v SPEAKER_00>What happens if you've pushed as much as you can onto an arena,

646
00:34:41.072 --> 00:34:42.833
<v SPEAKER_00>but you need some new allocation,

647
00:34:43.313 --> 00:34:48.996
<v SPEAKER_00>and the allocation pointer is just not far enough from the top of the arena for you

648
00:34:49.016 --> 00:34:49.697
<v SPEAKER_00>to push that thing on?

649
00:34:50.277 --> 00:34:52.058
<v SPEAKER_00>Well, there are three options.

650
00:34:52.918 --> 00:34:55.400
<v SPEAKER_00>Option one, you could stop the program.

651
00:34:55.560 --> 00:34:56.080
<v SPEAKER_00>You'd just panic.

652
00:34:57.378 --> 00:35:01.721
<v SPEAKER_00> Option two, you can push a new chunk of memory onto a linked list.

653
00:35:01.922 --> 00:35:08.006
<v SPEAKER_00>You can reserve a new block that's capable of filling the requirements for your new allocation.

654
00:35:08.967 --> 00:35:14.151
<v SPEAKER_00>And then there's this third option, which comes from what I spoke about earlier, where

655
00:35:16.638 --> 00:35:21.081
<v SPEAKER_00>we can take advantage of the fact that what we think of as addresses,

656
00:35:21.162 --> 00:35:21.902
<v SPEAKER_00>memory addresses,

657
00:35:22.643 --> 00:35:23.784
<v SPEAKER_00>that's virtual address space.

658
00:35:23.804 --> 00:35:25.165
<v SPEAKER_00>That's not physical memory.

659
00:35:25.205 --> 00:35:26.726
<v SPEAKER_00>That's sort of in this world of addresses.

660
00:35:28.907 --> 00:35:32.410
<v SPEAKER_00>And so we can reserve a huge portion of virtual address space,

661
00:35:32.971 --> 00:35:34.472
<v SPEAKER_00>so something like 8 gigabytes,

662
00:35:34.472 --> 00:35:35.092
<v SPEAKER_00>64 gigabytes,

663
00:35:35.092 --> 00:35:36.313
<v SPEAKER_00>256 gigabytes.

664
00:35:37.654 --> 00:35:42.078
<v SPEAKER_00>But that doesn't contribute that much to how much memory we actually have to commit

665
00:35:42.198 --> 00:35:43.078
<v SPEAKER_00>inside of our process.

666
00:35:43.559 --> 00:35:46.321
<v SPEAKER_00>It's just reserving the addresses, which is actually much cheaper.

667
00:35:47.682 --> 00:35:51.646
<v SPEAKER_00>And then when we need to push more onto the arena than we've actually physically

668
00:35:51.686 --> 00:35:52.427
<v SPEAKER_00>backed with memory,

669
00:35:52.807 --> 00:35:54.729
<v SPEAKER_00>we can commit pages as necessary.

670
00:35:56.711 --> 00:36:01.116
<v SPEAKER_00>So remember, an address space, 256 terabytes.

671
00:36:02.337 --> 00:36:06.141
<v SPEAKER_00>You can simply do something like reserve 64 gigabytes for an arena.

672
00:36:09.284 --> 00:36:13.285
<v SPEAKER_00> Never have to think about it again, because you have 256 terabytes worth of address space.

673
00:36:14.145 --> 00:36:16.006
<v SPEAKER_00>You can also combine options two and three.

674
00:36:16.026 --> 00:36:17.806
<v SPEAKER_00>Oh, whoops.

675
00:36:18.966 --> 00:36:20.207
<v SPEAKER_00>You can combine these two options.

676
00:36:20.247 --> 00:36:25.308
<v SPEAKER_00>You can have a mixed strategy where you prefer, for example, reserve commit.

677
00:36:25.328 --> 00:36:29.589
<v SPEAKER_00>You prefer option three, but then only to a fixed relatively lower size.

678
00:36:29.609 --> 00:36:32.369
<v SPEAKER_00>If you don't want to waste too much address space per arena or something like that,

679
00:36:32.750 --> 00:36:34.030
<v SPEAKER_00>you can combine these strategies.

680
00:36:37.571 --> 00:36:38.711
<v SPEAKER_00>But there are options, right?

681
00:36:41.681 --> 00:36:42.522
<v SPEAKER_00>So number one,

682
00:36:43.302 --> 00:36:46.563
<v SPEAKER_00>one immediate benefit of doing the reserve commit style thing,

683
00:36:46.663 --> 00:36:49.063
<v SPEAKER_00>one clear thing that just falls out of it immediately,

684
00:36:50.123 --> 00:36:52.244
<v SPEAKER_00>is you can have dynamic arrays.

685
00:36:52.284 --> 00:36:59.366
<v SPEAKER_00>You can grow blocks of memory without ever having to relocate them in address space.

686
00:37:01.067 --> 00:37:04.870
<v SPEAKER_00> And so if anyone here has written C++, you've probably run into this.

687
00:37:05.010 --> 00:37:08.352
<v SPEAKER_00>I ran into this when I wrote C++ before because I didn't read the docs.

688
00:37:08.512 --> 00:37:11.574
<v SPEAKER_00>But you can have an STD vector of foos,

689
00:37:11.854 --> 00:37:13.596
<v SPEAKER_00>and you grab a pointer to a foo,

690
00:37:13.716 --> 00:37:14.716
<v SPEAKER_00>and then you push back,

691
00:37:15.257 --> 00:37:16.938
<v SPEAKER_00>and then later you try to access the pointer.

692
00:37:18.496 --> 00:37:19.858
<v SPEAKER_00> And that's not allowed.

693
00:37:19.878 --> 00:37:21.419
<v SPEAKER_00>You can't do that.

694
00:37:21.600 --> 00:37:21.800
<v SPEAKER_00>I mean,

695
00:37:22.381 --> 00:37:22.741
<v SPEAKER_00>you could,

696
00:37:22.781 --> 00:37:25.724
<v SPEAKER_00>but you'd have to parametrize the STD vector with a different STD allocator or

697
00:37:25.745 --> 00:37:26.365
<v SPEAKER_00>something like that.

698
00:37:27.006 --> 00:37:33.674
<v SPEAKER_00>But point is, in the docs it says, after you've pushed back, iterators, pointers to things, all wrong.

699
00:37:33.954 --> 00:37:34.455
<v SPEAKER_00>Don't use them.

700
00:37:36.445 --> 00:37:43.392
<v SPEAKER_00> But with our arena strategy, we can just not do that.

701
00:37:43.472 --> 00:37:45.935
<v SPEAKER_00>The address space stays in the same spot.

702
00:37:46.815 --> 00:37:50.599
<v SPEAKER_00>If we push new things onto the arena, commit more pages as necessary, then

703
00:37:51.809 --> 00:37:53.390
<v SPEAKER_00> We just commit more pages.

704
00:37:53.430 --> 00:37:54.391
<v SPEAKER_00>We have access to those.

705
00:37:55.612 --> 00:38:01.016
<v SPEAKER_00>We have access to physical pages backing the initial address space reservation that we made.

706
00:38:01.036 --> 00:38:07.762
<v SPEAKER_00>So you can have just these absurdly large fixed size, technically fixed size cap dynamic arrays.

707
00:38:08.522 --> 00:38:12.685
<v SPEAKER_00>The cap just happens to be like 64 gigabytes or 256 gigabytes.

708
00:38:14.327 --> 00:38:19.751
<v SPEAKER_00>And the thing about an arena is that it's actually pretty simple to implement.

709
00:38:19.831 --> 00:38:20.512
<v SPEAKER_00>It's just a stack.

710
00:38:22.207 --> 00:38:23.187
<v SPEAKER_00>So this thing,

711
00:38:23.228 --> 00:38:23.348
<v SPEAKER_00>like,

712
00:38:23.388 --> 00:38:25.208
<v SPEAKER_00>I pulled this from my code base,

713
00:38:25.948 --> 00:38:26.849
<v SPEAKER_00>and you can implement it in,

714
00:38:26.889 --> 00:38:27.029
<v SPEAKER_00>like,

715
00:38:27.029 --> 00:38:27.949
<v SPEAKER_00>200 lines of code,

716
00:38:28.329 --> 00:38:28.789
<v SPEAKER_00>including all,

717
00:38:28.829 --> 00:38:29.009
<v SPEAKER_00>like,

718
00:38:29.069 --> 00:38:31.890
<v SPEAKER_00>the reserve commit stuff that I just spoke about.

719
00:38:34.051 --> 00:38:35.771
<v SPEAKER_00>And so if we just walk through the API,

720
00:38:35.791 --> 00:38:37.912
<v SPEAKER_00>it might be a little hard to read on this screen,

721
00:38:38.012 --> 00:38:38.152
<v SPEAKER_00>but...

722
00:38:40.033 --> 00:38:40.153
<v SPEAKER_00>So,

723
00:38:40.233 --> 00:38:40.473
<v SPEAKER_00>I mean,

724
00:38:40.533 --> 00:38:40.793
<v SPEAKER_00>first,

725
00:38:41.173 --> 00:38:42.493
<v SPEAKER_00>you have the calls I spoke about earlier,

726
00:38:42.513 --> 00:38:43.894
<v SPEAKER_00>arena-alloc.

727
00:38:46.055 --> 00:38:46.655
<v SPEAKER_00> arena release.

728
00:38:46.675 --> 00:38:50.656
<v SPEAKER_00>So that's just if you want to reserve the address space, get it ready for using as an arena.

729
00:38:50.736 --> 00:38:55.398
<v SPEAKER_00>And then you can also just get rid of all the address space to be reused later.

730
00:38:55.678 --> 00:38:57.979
<v SPEAKER_00>That's sort of the malloc and freestyle interface at the very bottom.

731
00:39:00.739 --> 00:39:02.860
<v SPEAKER_00>You can also like, whoops, whoa.

732
00:39:04.400 --> 00:39:06.241
<v SPEAKER_00> You can also set some probability.

733
00:39:06.561 --> 00:39:10.203
<v SPEAKER_00>An arena could have the feature of automatically aligning to some boundary if

734
00:39:10.243 --> 00:39:11.423
<v SPEAKER_00>that's important or whatever.

735
00:39:13.044 --> 00:39:15.425
<v SPEAKER_00>And then all the important calls are basically right here.

736
00:39:15.665 --> 00:39:17.106
<v SPEAKER_00>You have these push variants.

737
00:39:17.906 --> 00:39:19.447
<v SPEAKER_00>You can push onto the arena.

738
00:39:19.507 --> 00:39:23.569
<v SPEAKER_00>You can pop off the arena, including a full clear if you just don't want to keep anything.

739
00:39:27.638 --> 00:39:32.280
<v SPEAKER_00>These are some useful macros that I use for anyone wanting to do this in C,

740
00:39:32.840 --> 00:39:38.502
<v SPEAKER_00>where you don't have to do the cast in C anyways.

741
00:39:38.542 --> 00:39:40.323
<v SPEAKER_00>But if you're in C++, you can do the cast here.

742
00:39:40.803 --> 00:39:42.264
<v SPEAKER_00>You can automatically calculate the size.

743
00:39:42.544 --> 00:39:43.484
<v SPEAKER_00>Makes it a little bit simpler.

744
00:39:44.144 --> 00:39:50.086
<v SPEAKER_00>One thing that's maybe worth noting is a convention that I recently started doing is I just

745
00:39:53.086 --> 00:39:54.687
<v SPEAKER_00> Push automatically zeroes the memory.

746
00:39:54.707 --> 00:39:57.549
<v SPEAKER_00>So you can see the default is to just zero.

747
00:39:57.990 --> 00:40:00.872
<v SPEAKER_00>And then you can also have a no zero equivalent if you just want to do the push,

748
00:40:00.912 --> 00:40:02.153
<v SPEAKER_00>if you know it's going to be filled or whatever.

749
00:40:05.155 --> 00:40:06.536
<v SPEAKER_00>And so how does this look like in practice?

750
00:40:06.556 --> 00:40:08.578
<v SPEAKER_00>Well, it's not that different from the example slides.

751
00:40:09.198 --> 00:40:10.840
<v SPEAKER_00>If I wanted a bunch of string functions,

752
00:40:12.301 --> 00:40:14.703
<v SPEAKER_00>that do a number of common string operations,

753
00:40:14.943 --> 00:40:16.284
<v SPEAKER_00>producing a format string,

754
00:40:17.344 --> 00:40:21.167
<v SPEAKER_00>splitting a string by substrings that you'd want to split on,

755
00:40:22.027 --> 00:40:23.929
<v SPEAKER_00>joining a string list,

756
00:40:23.969 --> 00:40:26.750
<v SPEAKER_00>like something that comes back from a split operation,

757
00:40:26.830 --> 00:40:29.692
<v SPEAKER_00>joining that into a contiguous string with different separators or something like that.

758
00:40:30.133 --> 00:40:30.593
<v SPEAKER_00>All of those,

759
00:40:31.173 --> 00:40:31.674
<v SPEAKER_00>you can see,

760
00:40:31.734 --> 00:40:33.054
<v SPEAKER_00>they just take an arena parameter,

761
00:40:33.515 --> 00:40:36.297
<v SPEAKER_00>and then you pass whatever arena is required there,

762
00:40:36.317 --> 00:40:36.797
<v SPEAKER_00>and then you're done.

763
00:40:38.960 --> 00:40:42.022
<v SPEAKER_00> It also works for parsers.

764
00:40:43.843 --> 00:40:47.125
<v SPEAKER_00>So if you wanted to produce a buffer of tokens given some text,

765
00:40:47.705 --> 00:40:50.267
<v SPEAKER_00>you just pass the arena that you want,

766
00:40:50.287 --> 00:40:52.408
<v SPEAKER_00>and then you get a buffer of tokens back.

767
00:40:52.949 --> 00:40:56.371
<v SPEAKER_00>And then you can pass those tokens into the parsing from text tokens function,

768
00:40:56.391 --> 00:40:59.773
<v SPEAKER_00>and then you'll get the abstract syntax tree back.

769
00:40:59.813 --> 00:41:00.833
<v SPEAKER_00>And you just pass the arena.

770
00:41:00.853 --> 00:41:01.774
<v SPEAKER_00>There's no free call,

771
00:41:02.234 --> 00:41:03.455
<v SPEAKER_00>because bypassing the arena,

772
00:41:03.875 --> 00:41:06.237
<v SPEAKER_00>you've said everything you need to say about the freeze.

773
00:41:08.862 --> 00:41:09.382
<v SPEAKER_00>And like I said,

774
00:41:09.462 --> 00:41:10.783
<v SPEAKER_00>an arena could be used as a stack,

775
00:41:11.463 --> 00:41:13.424
<v SPEAKER_00>where to do that,

776
00:41:13.504 --> 00:41:16.405
<v SPEAKER_00>all you need to do is remember the arena and the position.

777
00:41:17.145 --> 00:41:21.146
<v SPEAKER_00>And then you grab that position.

778
00:41:21.166 --> 00:41:23.507
<v SPEAKER_00>And then when you're done in that sort of temporary window,

779
00:41:24.787 --> 00:41:29.229
<v SPEAKER_00>you can end that temporary window just by popping the arena back to whatever

780
00:41:29.249 --> 00:41:30.929
<v SPEAKER_00>position you remembered.

781
00:41:32.850 --> 00:41:35.831
<v SPEAKER_00>And so what you can do with that is

782
00:41:38.331 --> 00:41:40.192
<v SPEAKER_00>If you wanted to use an arena like a stack,

783
00:41:40.393 --> 00:41:46.617
<v SPEAKER_00>so if you wanted it to correspond with your call stack,

784
00:41:47.238 --> 00:41:51.901
<v SPEAKER_00>then you can just have a couple of thread local arenas that you use for that purpose.

785
00:41:52.542 --> 00:41:55.184
<v SPEAKER_00>And you can see me using that in this example,

786
00:41:55.244 --> 00:41:57.446
<v SPEAKER_00>like UI button function that I have here,

787
00:41:59.547 --> 00:42:01.949
<v SPEAKER_00>where I've passed in a format string arguments.

788
00:42:02.129 --> 00:42:07.654
<v SPEAKER_00>So I have the char star format, like the C string, if you want to put a format string into a button.

789
00:42:09.133 --> 00:42:11.914
<v SPEAKER_00> which is just a wrapper around this UI button call.

790
00:42:12.835 --> 00:42:16.136
<v SPEAKER_00>And what I need to do is this isn't the string I need.

791
00:42:16.156 --> 00:42:17.457
<v SPEAKER_00>I need to produce a format string.

792
00:42:17.497 --> 00:42:20.659
<v SPEAKER_00>And so I do all the crap of valist args,

793
00:42:20.699 --> 00:42:21.139
<v SPEAKER_00>all that stuff,

794
00:42:21.279 --> 00:42:23.820
<v SPEAKER_00>allocate a format string onto a scratch arena locally.

795
00:42:23.840 --> 00:42:27.402
<v SPEAKER_00>And then I just call the UI button function normally.

796
00:42:28.062 --> 00:42:31.103
<v SPEAKER_00>And then I release the scratch at the end.

797
00:42:33.988 --> 00:42:36.630
<v SPEAKER_00> I guess I could have used those slides, but there you go.

798
00:42:36.910 --> 00:42:37.851
<v SPEAKER_00>So why use that?

799
00:42:37.931 --> 00:42:39.852
<v SPEAKER_00>Why use a thread local scratch arena at all?

800
00:42:39.892 --> 00:42:40.893
<v SPEAKER_00>You have the stack already.

801
00:42:41.073 --> 00:42:41.573
<v SPEAKER_00>What's the deal?

802
00:42:42.313 --> 00:42:45.576
<v SPEAKER_00>Turns out that if you write all of your code,

803
00:42:45.636 --> 00:42:48.197
<v SPEAKER_00>if you adopt this rule of take an arena when you want to allocate,

804
00:42:48.878 --> 00:42:50.399
<v SPEAKER_00>by having a thread local scratch arena,

805
00:42:50.519 --> 00:42:55.922
<v SPEAKER_00>you've now sort of exposed the call stack's lifetime via this arena interface.

806
00:42:55.942 --> 00:43:00.765
<v SPEAKER_00>And so you can plug that lifetime into any code that you wrote for an arena.

807
00:43:04.454 --> 00:43:05.755
<v SPEAKER_00>So there's a subtle problem here,

808
00:43:05.955 --> 00:43:07.457
<v SPEAKER_00>which maybe this will get into the weeds a little bit,

809
00:43:07.477 --> 00:43:08.758
<v SPEAKER_00>but I think it's worth covering.

810
00:43:10.825 --> 00:43:15.009
<v SPEAKER_00> Imagine you just had a single scratch arena, thread local scratch arena.

811
00:43:15.829 --> 00:43:17.811
<v SPEAKER_00>And you grab it.

812
00:43:17.831 --> 00:43:19.432
<v SPEAKER_00>Let's say I'm in foo first.

813
00:43:19.893 --> 00:43:22.135
<v SPEAKER_00>And I'm like, well, I really need to call into bar to get some stuff.

814
00:43:22.555 --> 00:43:24.036
<v SPEAKER_00>And so I grab the scratch arena here.

815
00:43:24.517 --> 00:43:28.140
<v SPEAKER_00>And so I pass in the scratch arena into bar because I wanted to allocate just locally.

816
00:43:28.200 --> 00:43:29.781
<v SPEAKER_00>I don't need it for that long.

817
00:43:29.801 --> 00:43:31.823
<v SPEAKER_00>I just need to do some intermediate computations or something.

818
00:43:32.243 --> 00:43:33.644
<v SPEAKER_00>And I release the scratch at the end.

819
00:43:34.525 --> 00:43:35.226
<v SPEAKER_00>And in bar,

820
00:43:36.351 --> 00:43:38.633
<v SPEAKER_00> It's like, OK, so I have this arena I need to allocate on.

821
00:43:39.193 --> 00:43:42.315
<v SPEAKER_00>But I also need a scratch arena to perform some intermediate computations.

822
00:43:42.855 --> 00:43:46.018
<v SPEAKER_00>And so I'll push some stuff onto the output arena, just arena.

823
00:43:46.738 --> 00:43:50.581
<v SPEAKER_00>And then I'll push all my scratch stuff onto the scratch arena.

824
00:43:50.601 --> 00:43:53.623
<v SPEAKER_00>And then I'll release the scratch and then return the stuff.

825
00:43:53.643 --> 00:43:54.283
<v SPEAKER_00>So what's the issue?

826
00:43:56.344 --> 00:43:58.326
<v SPEAKER_00>Well, all three of these arenas are the same thing.

827
00:43:59.910 --> 00:44:03.993
<v SPEAKER_00>So by the time release scratch is called here,

828
00:44:04.473 --> 00:44:08.597
<v SPEAKER_00>it's actually popping off all the stuff that went onto this arena up here.

829
00:44:08.637 --> 00:44:13.681
<v SPEAKER_00>And so this is a problem that maybe is best referred to as arena aliasing.

830
00:44:13.701 --> 00:44:17.024
<v SPEAKER_00>You have two different arenas, and they're sort of conflicting.

831
00:44:17.044 --> 00:44:18.706
<v SPEAKER_00>You think they're for different purposes, but they're not.

832
00:44:19.727 --> 00:44:21.108
<v SPEAKER_00> So what are the options here?

833
00:44:21.128 --> 00:44:22.870
<v SPEAKER_00>If we want to make this thing kind of work,

834
00:44:23.770 --> 00:44:24.131
<v SPEAKER_00>number one,

835
00:44:24.151 --> 00:44:25.832
<v SPEAKER_00>we could just have a pool of arenas per thread,

836
00:44:26.172 --> 00:44:27.653
<v SPEAKER_00>where once you grab one as a scratch,

837
00:44:27.673 --> 00:44:28.954
<v SPEAKER_00>it can't be used later.

838
00:44:30.596 --> 00:44:31.416
<v SPEAKER_00>Some downsides to it.

839
00:44:31.516 --> 00:44:33.918
<v SPEAKER_00>It's more expensive per thread.

840
00:44:34.219 --> 00:44:36.721
<v SPEAKER_00>You need n possible arenas per thread.

841
00:44:37.561 --> 00:44:40.143
<v SPEAKER_00>And you can only go sort of n.

842
00:44:41.573 --> 00:44:49.056
<v SPEAKER_00> You can go O of n layers deep in your call stack if O of n frames in the stack use a scratch arena.

843
00:44:49.076 --> 00:44:50.457
<v SPEAKER_00>You can't have super deep call stacks,

844
00:44:50.497 --> 00:44:51.797
<v SPEAKER_00>which maybe you shouldn't anyways,

845
00:44:51.877 --> 00:44:54.758
<v SPEAKER_00>but that's a serious limitation.

846
00:44:55.439 --> 00:44:56.559
<v SPEAKER_00>But there's a second option,

847
00:44:57.400 --> 00:45:06.543
<v SPEAKER_00>which is git scratch simply needs to return an arena that does not match with an

848
00:45:06.563 --> 00:45:07.624
<v SPEAKER_00>arena passed by the caller.

849
00:45:10.783 --> 00:45:18.028
<v SPEAKER_00> And so an example of doing that, that's what those two 0, 0 parameters were in the first example.

850
00:45:18.449 --> 00:45:21.951
<v SPEAKER_00>You can see in this parsing function I've got, I need a scratch.

851
00:45:23.152 --> 00:45:27.595
<v SPEAKER_00>But I've been passed an arena by the caller because I'm allocating an abstract syntax tree.

852
00:45:29.757 --> 00:45:34.260
<v SPEAKER_00>And the first thing I do when I grab the scratch is I pass in the arena that the

853
00:45:34.300 --> 00:45:35.260
<v SPEAKER_00>scratch arena cannot match.

854
00:45:36.295 --> 00:45:41.406
<v SPEAKER_00> And when I push things onto the output arena, they don't match the scratch arena that I had before.

855
00:45:41.948 --> 00:45:43.892
<v SPEAKER_00>So that's a simple way around this kind of problem.

856
00:45:45.776 --> 00:45:46.417
<v SPEAKER_00>But you can imagine.

857
00:45:49.989 --> 00:45:53.172
<v SPEAKER_00>Maybe you could think that if this function called into something else that needed

858
00:45:53.192 --> 00:45:53.572
<v SPEAKER_00>a scratch,

859
00:45:53.732 --> 00:45:54.553
<v SPEAKER_00>it passed its scratch.

860
00:45:54.853 --> 00:45:59.878
<v SPEAKER_00>There's actually no problem if you have at least two scratches in the thread local storage.

861
00:45:59.918 --> 00:46:05.423
<v SPEAKER_00>Because if I'm in this call frame, I've got this arena, which could have been a scratch for my caller.

862
00:46:05.803 --> 00:46:08.325
<v SPEAKER_00>And then I have this scratch, which is a second one.

863
00:46:08.966 --> 00:46:12.689
<v SPEAKER_00>If I call into a third function, which also needs to get a scratch, it can also be this one.

864
00:46:13.970 --> 00:46:17.293
<v SPEAKER_00> which is a little subtle and kind of hard to get into in a case like this.

865
00:46:17.353 --> 00:46:21.496
<v SPEAKER_00>But if I call into a function in here,

866
00:46:21.957 --> 00:46:23.358
<v SPEAKER_00>which needed to use a scratch arena,

867
00:46:24.358 --> 00:46:30.683
<v SPEAKER_00>it'll pop everything off above where any results for the caller were allocated.

868
00:46:30.763 --> 00:46:32.445
<v SPEAKER_00>So maybe a little off in the weeds,

869
00:46:32.485 --> 00:46:36.348
<v SPEAKER_00>but you can ask questions about it if you're trying to figure that out a little bit more.

870
00:46:39.230 --> 00:46:40.110
<v SPEAKER_00>So let's get to the big issue.

871
00:46:41.073 --> 00:46:45.022
<v SPEAKER_00> You're like, these arena things sound pretty great, but there's a little problem here.

872
00:46:46.605 --> 00:46:47.767
<v SPEAKER_00>You can't free things out of the middle.

873
00:46:50.811 --> 00:46:54.212
<v SPEAKER_00> But as it turns out, it's pretty simple to get around that problem.

874
00:46:55.892 --> 00:47:01.014
<v SPEAKER_00>Even though a block of memory you've reserved for some purpose does have to

875
00:47:01.454 --> 00:47:03.875
<v SPEAKER_00>correspond with one uniform lifetime,

876
00:47:04.095 --> 00:47:08.076
<v SPEAKER_00>there are things that you might have within that lifetime that you want to reuse.

877
00:47:08.236 --> 00:47:10.636
<v SPEAKER_00>If you have entities in a video game or something like that,

878
00:47:11.117 --> 00:47:15.198
<v SPEAKER_00>some entity spawns and then it gets hit by an arrow and then it has to despawn and

879
00:47:15.238 --> 00:47:16.678
<v SPEAKER_00>be reused for some other purpose,

880
00:47:17.358 --> 00:47:19.579
<v SPEAKER_00>you can approach that with something called a free list.

881
00:47:20.279 --> 00:47:20.479
<v SPEAKER_00>which,

882
00:47:20.599 --> 00:47:28.647
<v SPEAKER_00>if you just have a pointer to a node in each one of the slots here in this block of memory,

883
00:47:28.827 --> 00:47:31.850
<v SPEAKER_00>each slot would have a pointer.

884
00:47:33.011 --> 00:47:38.296
<v SPEAKER_00>And you can have a free list where you start with the free list,

885
00:47:38.316 --> 00:47:40.518
<v SPEAKER_00>and then it points through a chain of all the free nodes.

886
00:47:41.599 --> 00:47:44.922
<v SPEAKER_00>And if you need to allocate something, the first thing you do is check the free list.

887
00:47:45.888 --> 00:47:50.112
<v SPEAKER_00> And if you want to free something, the first thing you do is push on to the free list.

888
00:47:50.132 --> 00:47:53.595
<v SPEAKER_00>You just set the next pointer and then replace the top of the free list.

889
00:47:54.336 --> 00:47:58.079
<v SPEAKER_00>And then if the free list is empty, then that's when you actually grow the arena.

890
00:47:59.000 --> 00:48:01.202
<v SPEAKER_00>And so here's an example of how that looks like in code.

891
00:48:02.263 --> 00:48:06.767
<v SPEAKER_00>You can see the allocator I'm using is just the arena together with the free list.

892
00:48:06.967 --> 00:48:08.788
<v SPEAKER_00>I've got this foo thing.

893
00:48:08.808 --> 00:48:11.851
<v SPEAKER_00>You can imagine this being a game entity or something like that.

894
00:48:11.871 --> 00:48:12.772
<v SPEAKER_00>It's got this pointer there.

895
00:48:14.572 --> 00:48:15.353
<v SPEAKER_00>And it's worth noticing,

896
00:48:15.393 --> 00:48:15.533
<v SPEAKER_00>like,

897
00:48:16.134 --> 00:48:17.736
<v SPEAKER_00>the pointer does not have to be the...

898
00:48:18.517 --> 00:48:20.259
<v SPEAKER_00>You can just consider this a pointer,

899
00:48:20.639 --> 00:48:24.043
<v SPEAKER_00>this portion of foo as a pointer if it's in the free list.

900
00:48:24.083 --> 00:48:27.928
<v SPEAKER_00>You don't have to necessarily occupy space in sort of the live data structure for a

901
00:48:27.968 --> 00:48:28.328
<v SPEAKER_00>free list,

902
00:48:28.368 --> 00:48:30.911
<v SPEAKER_00>but I just made this case simple,

903
00:48:30.951 --> 00:48:32.473
<v SPEAKER_00>which is what I usually do in practice anyways.

904
00:48:35.174 --> 00:48:39.800
<v SPEAKER_00> When you call foo alloc, you can see I'm doing that part where I'm just grabbing the free list.

905
00:48:40.261 --> 00:48:45.507
<v SPEAKER_00>And if the free list was not empty,

906
00:48:45.907 --> 00:48:47.349
<v SPEAKER_00>meaning I got something off the free list,

907
00:48:47.729 --> 00:48:50.292
<v SPEAKER_00>I move the top of the free list back one slot.

908
00:48:50.753 --> 00:48:52.855
<v SPEAKER_00>And then I just zero the struct or whatever I want to do.

909
00:48:54.258 --> 00:48:57.859
<v SPEAKER_00> And if the free list was empty, then I just push onto the arena.

910
00:48:57.879 --> 00:49:01.601
<v SPEAKER_00>You can actually see I'm still using the old convention in this code where I have push array 0.

911
00:49:02.601 --> 00:49:04.742
<v SPEAKER_00>And that's when I push onto the arena.

912
00:49:04.762 --> 00:49:05.722
<v SPEAKER_00>And then I return foo.

913
00:49:06.283 --> 00:49:10.884
<v SPEAKER_00>And then when I release foo, all I'm doing is pushing this foo onto the free list.

914
00:49:11.045 --> 00:49:14.206
<v SPEAKER_00>I'm pointing foo to the top of the free list right now, which could be 0.

915
00:49:15.126 --> 00:49:16.728
<v SPEAKER_00> And then the top of the free list just becomes foo.

916
00:49:16.888 --> 00:49:17.629
<v SPEAKER_00>And that's how you release.

917
00:49:17.890 --> 00:49:18.751
<v SPEAKER_00>So it's very simple.

918
00:49:18.871 --> 00:49:23.676
<v SPEAKER_00>If you have one particular type that you just need to reuse slots for, you just do this.

919
00:49:23.877 --> 00:49:28.062
<v SPEAKER_00>And then you have basically a growing pool allocator on top of an arena.

920
00:49:30.356 --> 00:49:33.097
<v SPEAKER_00> And so more sophisticated allocators work in precisely the same way.

921
00:49:33.617 --> 00:49:36.338
<v SPEAKER_00>And if you actually dig into implementations of malloc,

922
00:49:36.358 --> 00:49:36.879
<v SPEAKER_00>for example,

923
00:49:37.139 --> 00:49:38.699
<v SPEAKER_00>they're kind of doing all this stuff.

924
00:49:39.220 --> 00:49:41.801
<v SPEAKER_00>It's just that in most cases, you don't need something that complicated.

925
00:49:43.621 --> 00:49:47.843
<v SPEAKER_00>So this is an example of another kind of complicated allocator that I wrote on top

926
00:49:47.883 --> 00:49:48.363
<v SPEAKER_00>of an arena,

927
00:49:48.403 --> 00:49:53.245
<v SPEAKER_00>which is sort of this quadtree Atlas allocator.

928
00:49:53.685 --> 00:49:55.086
<v SPEAKER_00>And I wanted it to be an allocator,

929
00:49:55.146 --> 00:49:56.487
<v SPEAKER_00>not like a packing function,

930
00:49:56.507 --> 00:49:59.848
<v SPEAKER_00>because this had to be like a dynamic cache structure.

931
00:50:01.243 --> 00:50:04.605
<v SPEAKER_00> where I didn't want to have serious fragmentation or something inside of this cache.

932
00:50:05.926 --> 00:50:08.728
<v SPEAKER_00>The point is, this is all implemented on top of an arena, too.

933
00:50:08.768 --> 00:50:09.068
<v SPEAKER_00>You can see,

934
00:50:09.108 --> 00:50:10.049
<v SPEAKER_00>if you look at the interface,

935
00:50:10.569 --> 00:50:13.831
<v SPEAKER_00>I can allocate regions and release them with their own independent lifetimes.

936
00:50:13.871 --> 00:50:17.514
<v SPEAKER_00>But those are all sort of scoped by the arena that I'm using for the Atlas.

937
00:50:20.956 --> 00:50:23.658
<v SPEAKER_00>And so what's the point?

938
00:50:23.798 --> 00:50:24.518
<v SPEAKER_00>What do we get for all this?

939
00:50:27.562 --> 00:50:29.223
<v SPEAKER_00> I need to come here so I can read the slide.

940
00:50:29.303 --> 00:50:30.244
<v SPEAKER_00>I don't have notes for this part.

941
00:50:31.624 --> 00:50:34.266
<v SPEAKER_00>Dynamically allocating memory now becomes basically free.

942
00:50:34.927 --> 00:50:38.349
<v SPEAKER_00>In the common case, you're bumping a pointer and taking it.

943
00:50:38.449 --> 00:50:39.910
<v SPEAKER_00>So all of the performance problems,

944
00:50:39.930 --> 00:50:40.691
<v SPEAKER_00>all the complexity,

945
00:50:40.791 --> 00:50:44.653
<v SPEAKER_00>the complex code paths that certain usage patterns of malloc can produce,

946
00:50:46.955 --> 00:50:48.236
<v SPEAKER_00>you don't hit any of those things.

947
00:50:48.676 --> 00:50:52.499
<v SPEAKER_00>In the best case with the malloc implementation, they're trying to approximate this kind of thing.

948
00:50:52.979 --> 00:50:54.520
<v SPEAKER_00>But with the arena, it's just every case.

949
00:50:54.700 --> 00:50:55.681
<v SPEAKER_00>You just have it all the time.

950
00:50:57.119 --> 00:51:00.522
<v SPEAKER_00> Releasing memory is also free.

951
00:51:00.542 --> 00:51:03.704
<v SPEAKER_00>You don't have to walk complicated forests of pointers or anything like that.

952
00:51:04.224 --> 00:51:06.606
<v SPEAKER_00>You just bump the pointer back to zero.

953
00:51:06.686 --> 00:51:12.191
<v SPEAKER_00>Or if you do want to release the arena, you have to pay the syscall cost of jettisoning the whole thing.

954
00:51:13.912 --> 00:51:16.274
<v SPEAKER_00>But importantly, releasing memory is a per lifetime concern.

955
00:51:16.534 --> 00:51:17.615
<v SPEAKER_00>It's not per allocation.

956
00:51:17.635 --> 00:51:21.197
<v SPEAKER_00>You don't have to worry about every single time you wanted to allocate something,

957
00:51:21.218 --> 00:51:23.099
<v SPEAKER_00>you also have to remember to go and free that thing.

958
00:51:26.167 --> 00:51:27.149
<v SPEAKER_00>And arenas,

959
00:51:27.749 --> 00:51:34.399
<v SPEAKER_00>they sort of become this little thing that you can click into any code path to work

960
00:51:34.499 --> 00:51:38.304
<v SPEAKER_00>for both a stack sort of situation and a heap allocation.

961
00:51:38.365 --> 00:51:41.990
<v SPEAKER_00>So all of the functions you write to an arena can apply to both cases now.

962
00:51:44.262 --> 00:51:48.524
<v SPEAKER_00> Number five, it's a 200 line implementation of an allocator that you control.

963
00:51:49.004 --> 00:51:54.907
<v SPEAKER_00>It means that diagnostics, logging, and visualization are trivial to go and add if you need to.

964
00:51:57.228 --> 00:52:02.570
<v SPEAKER_00>And allocations are already bucketed to a unique ID, which is the arena pointer that you passed in.

965
00:52:04.406 --> 00:52:04.846
<v SPEAKER_00>And I mean,

966
00:52:04.866 --> 00:52:05.487
<v SPEAKER_00>number six,

967
00:52:05.747 --> 00:52:07.088
<v SPEAKER_00>and this is maybe more philosophical,

968
00:52:07.529 --> 00:52:09.630
<v SPEAKER_00>some people don't need to worry about this,

969
00:52:09.710 --> 00:52:11.152
<v SPEAKER_00>but you don't need,

970
00:52:11.572 --> 00:52:14.514
<v SPEAKER_00>if you can control this level and become comfortable with arenas,

971
00:52:14.795 --> 00:52:17.477
<v SPEAKER_00>you don't need to depend on these complex tool chains and languages.

972
00:52:18.938 --> 00:52:21.360
<v SPEAKER_00>You can just use arenas in assembly, right?

973
00:52:21.680 --> 00:52:22.841
<v SPEAKER_00>That's kind of all you need.

974
00:52:23.622 --> 00:52:26.704
<v SPEAKER_00>And you don't need sophisticated language features.

975
00:52:27.325 --> 00:52:29.507
<v SPEAKER_00>You can take much more control over your problem.

976
00:52:31.271 --> 00:52:34.652
<v SPEAKER_00>And even if you are in a sort of higher level circumstance,

977
00:52:34.692 --> 00:52:37.693
<v SPEAKER_00>like you're working with modern languages,

978
00:52:37.734 --> 00:52:38.514
<v SPEAKER_00>with garbage collectors,

979
00:52:38.554 --> 00:52:39.654
<v SPEAKER_00>with automatic reference counting,

980
00:52:39.674 --> 00:52:40.194
<v SPEAKER_00>something like that,

981
00:52:41.155 --> 00:52:44.636
<v SPEAKER_00>you can still use the arena style techniques to make the problem easier for

982
00:52:44.656 --> 00:52:48.737
<v SPEAKER_00>yourself and easier for the garbage collector when those underlying abstractions

983
00:52:49.298 --> 00:52:49.978
<v SPEAKER_00>cause you problems,

984
00:52:50.298 --> 00:52:51.559
<v SPEAKER_00>like they inevitably do.

985
00:52:53.179 --> 00:52:55.340
<v SPEAKER_00>And so I've got a demo thing.

986
00:52:56.808 --> 00:53:01.713
<v SPEAKER_00>where I can walk through the code or just show some of the concepts that I spoke

987
00:53:01.733 --> 00:53:03.975
<v SPEAKER_00>about with the free list and stuff like that.

988
00:53:05.156 --> 00:53:06.617
<v SPEAKER_00>So I'll pull it up here.

989
00:53:08.498 --> 00:53:11.621
<v SPEAKER_00>And then if people have questions about how this works,

990
00:53:12.262 --> 00:53:13.643
<v SPEAKER_00>if they want to see more code examples,

991
00:53:14.243 --> 00:53:17.046
<v SPEAKER_00>I can do that too.

992
00:53:17.626 --> 00:53:18.487
<v SPEAKER_00>So it's very simple.

993
00:53:18.527 --> 00:53:19.248
<v SPEAKER_00>I wrote this yesterday.

994
00:53:20.849 --> 00:53:21.450
<v SPEAKER_00>It's very simple.

995
00:53:21.890 --> 00:53:23.612
<v SPEAKER_00>Oh god, this is going to be hard if I'm like, OK.

996
00:53:24.901 --> 00:53:29.044
<v SPEAKER_00> So point is, I can spawn entities, and these things just fly all around.

997
00:53:29.685 --> 00:53:30.725
<v SPEAKER_00>And I can just keep spawning them.

998
00:53:31.026 --> 00:53:34.608
<v SPEAKER_00>And you can imagine, if this is a pool allocator, I'm just pushing onto the arena right now.

999
00:53:34.628 --> 00:53:35.909
<v SPEAKER_00>I'm not reusing anything yet.

1000
00:53:38.291 --> 00:53:42.534
<v SPEAKER_00>One thing I can do is clear all, obviously, because arenas make that trivial.

1001
00:53:45.276 --> 00:53:51.461
<v SPEAKER_00>But if I spawn a bunch of things, and let me slow down the simulation right here.

1002
00:53:53.513 --> 00:53:54.653
<v SPEAKER_00> I can select one of these things.

1003
00:53:54.673 --> 00:53:55.774
<v SPEAKER_00>First of all, I can drag them around.

1004
00:53:55.794 --> 00:53:58.555
<v SPEAKER_00>And you'll see that each one of these things has a string attached to it.

1005
00:53:58.755 --> 00:54:00.435
<v SPEAKER_00>And a string is one of these things that people are like,

1006
00:54:01.195 --> 00:54:06.437
<v SPEAKER_00>this is why you can't use a simple allocator in a situation like this.

1007
00:54:07.377 --> 00:54:11.178
<v SPEAKER_00>But it turns out it's not actually that big of a deal.

1008
00:54:11.378 --> 00:54:12.819
<v SPEAKER_00>This is dynamically allocated.

1009
00:54:12.839 --> 00:54:15.680
<v SPEAKER_00>And I can just change whatever string I want.

1010
00:54:16.400 --> 00:54:18.320
<v SPEAKER_00>I can also delete this entity altogether.

1011
00:54:20.661 --> 00:54:21.561
<v SPEAKER_00>Just keep deleting them.

1012
00:54:22.642 --> 00:54:23.142
<v SPEAKER_00>Doesn't matter.

1013
00:54:24.684 --> 00:54:26.965
<v SPEAKER_00> And if I turn on the diagnostics here, you can see.

1014
00:54:26.985 --> 00:54:28.525
<v SPEAKER_00>You know, I can't really see.

1015
00:54:31.026 --> 00:54:35.928
<v SPEAKER_00>But yeah, so I mean, what I've done here is I've just logged.

1016
00:54:36.008 --> 00:54:36.788
<v SPEAKER_00>I've had a visual log.

1017
00:54:36.908 --> 00:54:37.868
<v SPEAKER_00>Again, wrote this yesterday.

1018
00:54:37.888 --> 00:54:39.069
<v SPEAKER_00>It's not that impressive of a log.

1019
00:54:41.140 --> 00:54:42.961
<v SPEAKER_00> You can see I've got these three arenas.

1020
00:54:43.182 --> 00:54:44.703
<v SPEAKER_00>It shows you how much I've reserved for them.

1021
00:54:44.723 --> 00:54:47.025
<v SPEAKER_00>They're just simple reserve commit style arenas.

1022
00:54:47.085 --> 00:54:47.846
<v SPEAKER_00>I don't do any chaining.

1023
00:54:48.386 --> 00:54:49.307
<v SPEAKER_00>And I've got three of them.

1024
00:54:49.607 --> 00:54:51.949
<v SPEAKER_00>I've got one for just the regular state.

1025
00:54:52.070 --> 00:54:53.911
<v SPEAKER_00>It's like there's nothing in there.

1026
00:54:54.011 --> 00:54:56.353
<v SPEAKER_00>But the name chunk arena,

1027
00:54:56.373 --> 00:55:00.037
<v SPEAKER_00>I'm using that for sort of discontinuous portions of strings that I just assumed a

1028
00:55:00.057 --> 00:55:00.737
<v SPEAKER_00>fixed size for.

1029
00:55:03.755 --> 00:55:06.956
<v SPEAKER_00> an entities arena where I reserved 64 gigabytes.

1030
00:55:07.456 --> 00:55:11.377
<v SPEAKER_00>And so far, I've committed about three kilobytes for all of the entities on the screen right now.

1031
00:55:11.777 --> 00:55:16.779
<v SPEAKER_00>And then these red portions are the free list tracing through available spots.

1032
00:55:17.259 --> 00:55:25.721
<v SPEAKER_00>And so if I go back and if I allocate a new entity, did that work?

1033
00:55:27.490 --> 00:55:30.593
<v SPEAKER_00> All right, yeah, so one of the nodes in the free list was just popped off, right?

1034
00:55:31.333 --> 00:55:32.394
<v SPEAKER_00>And so I've reused that spot.

1035
00:55:32.414 --> 00:55:33.835
<v SPEAKER_00>I didn't need to push anything onto it.

1036
00:55:34.576 --> 00:55:36.357
<v SPEAKER_00>I just needed to grab whatever's on the free list.

1037
00:55:38.639 --> 00:55:41.881
<v SPEAKER_00>So before I move on, are there any questions about this?

1038
00:55:41.981 --> 00:55:43.182
<v SPEAKER_00>Any code that you want to see?

1039
00:55:45.344 --> 00:55:45.464
<v SPEAKER_00>Yeah.

1040
00:55:46.725 --> 00:55:47.446
<v SPEAKER_00>So what was that?

1041
00:55:48.546 --> 00:55:52.149
<v SPEAKER_00>Oh, actually, you know, that might be good for sitting at the computer, yeah.

1042
00:55:52.910 --> 00:55:54.411
<v SPEAKER_02>We have an extra microphone as well here, so...

1043
00:55:55.091 --> 00:55:56.432
<v SPEAKER_00> That would be, yeah, that would be great.

1044
00:55:56.832 --> 00:56:01.816
<v SPEAKER_00>Oh, does it not work?

1045
00:56:01.916 --> 00:56:03.177
<v SPEAKER_00>Okay.

1046
00:56:04.118 --> 00:56:06.800
<v SPEAKER_00>I think that works, yeah.

1047
00:56:09.622 --> 00:56:11.643
<v SPEAKER_02>All right.

1048
00:56:11.703 --> 00:56:12.304
So it's...

1049
00:56:22.964 --> 00:56:24.184
<v SPEAKER_00> Let me show you exactly what I meant.

1050
00:56:24.204 --> 00:56:27.605
<v SPEAKER_00>There is a fixed size cap in there, which isn't strictly necessary.

1051
00:56:28.005 --> 00:56:30.106
<v SPEAKER_00>But I just did it for the sake of time and simplicity.

1052
00:56:32.146 --> 00:56:34.887
<v SPEAKER_00>The thing that has a fixed size cap are chunks of strings.

1053
00:56:34.907 --> 00:56:36.007
<v SPEAKER_00>They're not the strings themselves.

1054
00:56:36.547 --> 00:56:41.548
<v SPEAKER_00>And so what you store actually is a chain of chunks that are fixed size, as many as you need.

1055
00:56:42.269 --> 00:56:43.129
<v SPEAKER_00>And those do not conflict.

1056
00:56:43.149 --> 00:56:44.189
<v SPEAKER_00>It's just a fixed size pool.

1057
00:56:44.869 --> 00:56:47.050
<v SPEAKER_00>And I can show what that looks like here.

1058
00:56:48.230 --> 00:56:50.391
<v SPEAKER_00>So I've got this.

1059
00:56:51.491 --> 00:56:51.851
<v SPEAKER_00>Oh, shoot.

1060
00:56:53.612 --> 00:56:53.952
<v SPEAKER_00> There we go.

1061
00:56:56.114 --> 00:56:56.514
Oh, man.

1062
00:56:56.755 --> 00:56:57.235
<v SPEAKER_00>OK, hold on.

1063
00:56:58.196 --> 00:57:00.598
<v SPEAKER_00>Let me do one of these deals.

1064
00:57:03.560 --> 00:57:04.341
<v SPEAKER_00>Duplicate.

1065
00:57:05.201 --> 00:57:05.522
<v SPEAKER_00>Keep.

1066
00:57:07.603 --> 00:57:08.424
<v SPEAKER_00>This kind of thing.

1067
00:57:08.664 --> 00:57:09.845
<v SPEAKER_00>Where did four-coder go?

1068
00:57:09.925 --> 00:57:10.265
<v SPEAKER_00>Four-coder.

1069
00:57:10.486 --> 00:57:10.666
<v SPEAKER_00>OK.

1070
00:57:12.948 --> 00:57:14.889
<v SPEAKER_00>So can everyone read this OK?

1071
00:57:14.929 --> 00:57:15.930
<v SPEAKER_00>Or should I increase the size?

1072
00:57:19.653 --> 00:57:20.454
<v SPEAKER_00>I can do live mode, yeah.

1073
00:57:24.008 --> 00:57:25.429
<v SPEAKER_00> I can't believe you'd want to blind everyone.

1074
00:57:29.030 --> 00:57:33.291
<v SPEAKER_00>You lost syntax highlighting, but there you go.

1075
00:57:33.351 --> 00:57:35.092
<v SPEAKER_00>Actually, I won't do it.

1076
00:57:35.192 --> 00:57:35.612
<v SPEAKER_00>It doesn't matter.

1077
00:57:37.473 --> 00:57:40.814
<v SPEAKER_00>So the allocator you're referring to is the name allocator.

1078
00:57:41.354 --> 00:57:43.295
<v SPEAKER_00>And what you can see is when I want to allocate a name,

1079
00:57:43.355 --> 00:57:46.276
<v SPEAKER_00>I pass in whatever string has been constructed on some intermediate arena.

1080
00:57:48.257 --> 00:57:52.039
<v SPEAKER_00>And when I actually want to commit that to a stateful thing that I'm maintaining

1081
00:57:52.079 --> 00:57:53.440
<v SPEAKER_00>with this name allocator,

1082
00:57:54.620 --> 00:57:58.302
<v SPEAKER_00>what I'll do is I'll just loop through the portions of the string that need.

1083
00:58:00.250 --> 00:58:01.631
<v SPEAKER_00> that need chunks as needed.

1084
00:58:01.671 --> 00:58:04.793
<v SPEAKER_00>So you can see there's a name chunk payload size.

1085
00:58:05.253 --> 00:58:05.453
<v SPEAKER_00>And that's 56.

1086
00:58:05.553 --> 00:58:10.076
<v SPEAKER_00>And I did that just so a name chunk could start with eight bytes to the next chunk.

1087
00:58:10.457 --> 00:58:13.058
<v SPEAKER_00>And then the rest of the 56-byte block,

1088
00:58:13.379 --> 00:58:15.500
<v SPEAKER_00>or the rest of the 64-byte block,

1089
00:58:15.500 --> 00:58:16.180
<v SPEAKER_00>56 bytes,

1090
00:58:16.521 --> 00:58:17.821
<v SPEAKER_00>are used for contents of the string.

1091
00:58:18.502 --> 00:58:21.524
<v SPEAKER_00>And so when you try to allocate a name, you just grab how many chunks you need.

1092
00:58:21.884 --> 00:58:22.545
<v SPEAKER_00>You loop through them.

1093
00:58:23.365 --> 00:58:25.625
<v SPEAKER_00> And at that point, it's just a simple fixed-size free list.

1094
00:58:26.326 --> 00:58:28.306
<v SPEAKER_00>And then you just copy in the portions of the string.

1095
00:58:28.346 --> 00:58:31.586
<v SPEAKER_00>And then the thing you actually store is a name chunk list,

1096
00:58:33.227 --> 00:58:33.707
<v SPEAKER_00>which is a first,

1097
00:58:33.747 --> 00:58:33.987
<v SPEAKER_00>last,

1098
00:58:34.047 --> 00:58:34.927
<v SPEAKER_00>and count in total size.

1099
00:58:34.947 --> 00:58:35.107
<v SPEAKER_00>Yeah?

1100
00:58:35.387 --> 00:58:43.748
<v SPEAKER_02>The name is replaced somewhere for some size, but it doesn't reallocate for every single character type.

1101
00:58:43.788 --> 00:58:47.889
<v SPEAKER_00>It reallocates for every 56 character types.

1102
00:58:47.909 --> 00:58:48.009
<v SPEAKER_00>Right.

1103
00:58:49.529 --> 00:58:50.790
<v SPEAKER_00>Yep.

1104
00:58:50.810 --> 00:58:51.810
<v SPEAKER_00>And I could demo that.

1105
00:58:51.850 --> 00:58:52.030
<v SPEAKER_00>Sorry.

1106
00:58:52.050 --> 00:58:52.590
<v SPEAKER_00>Oh, sorry.

1107
00:58:54.141 --> 00:58:58.866
<v SPEAKER_00> Basically, each node in the free list of name chunks is going to be fixed size.

1108
00:58:59.667 --> 00:59:00.828
<v SPEAKER_00>So as you type,

1109
00:59:00.968 --> 00:59:01.409
<v SPEAKER_00>for example,

1110
00:59:01.429 --> 00:59:04.832
<v SPEAKER_00>if I made a name that was 64 characters,

1111
00:59:05.793 --> 00:59:07.915
<v SPEAKER_00>let's just say 100 characters,

1112
00:59:08.596 --> 00:59:12.920
<v SPEAKER_00>I would need two chunks if there's 56 useful bytes of payload per chunk.

1113
00:59:13.661 --> 00:59:16.183
<v SPEAKER_00>then what I would do is,

1114
00:59:16.803 --> 00:59:19.965
<v SPEAKER_00>as the user types the 57th character in the string,

1115
00:59:20.426 --> 00:59:24.609
<v SPEAKER_00>I would have to allocate a new chunk and store the string discontinuously across

1116
00:59:24.649 --> 00:59:25.389
<v SPEAKER_00>multiple regions.

1117
00:59:25.449 --> 00:59:26.990
<v SPEAKER_00>And then if I want to treat that as a string later,

1118
00:59:27.371 --> 00:59:30.753
<v SPEAKER_00>then I pay the cost of memcopying into a string when I need to,

1119
00:59:30.813 --> 00:59:31.313
<v SPEAKER_00>because that's free.

1120
00:59:34.035 --> 00:59:35.877
<v SPEAKER_00> You can also do a more sophisticated allocator here.

1121
00:59:35.897 --> 00:59:38.299
<v SPEAKER_00>I did a simple version just for this.

1122
00:59:38.399 --> 00:59:42.122
<v SPEAKER_00>But if you wanted to have multiple buckets of various sizes,

1123
00:59:42.162 --> 00:59:43.903
<v SPEAKER_00>depending on what data you're working with,

1124
00:59:44.344 --> 00:59:45.505
<v SPEAKER_00>you can just do that too.

1125
00:59:45.565 --> 00:59:46.986
<v SPEAKER_00>And that's kind of why I wrote it the way I did,

1126
00:59:47.046 --> 00:59:50.168
<v SPEAKER_00>where I didn't put a static buffer inside of this name chunk.

1127
00:59:50.248 --> 00:59:54.252
<v SPEAKER_00>Because you can imagine name chunk payload size being dynamic and having a bunch of

1128
00:59:54.272 --> 00:59:54.612
<v SPEAKER_00>free lists,

1129
00:59:54.652 --> 00:59:55.232
<v SPEAKER_00>not just one.

1130
00:59:55.252 --> 00:59:58.695
<v SPEAKER_00>It just kind of depends on what you want to do.

1131
00:59:59.156 --> 01:00:03.039
<v SPEAKER_00>So if I turn on the diagnostics here, and I turn down the simulation rate,

1132
01:00:04.482 --> 01:00:15.210
<v SPEAKER_00> And if I grab this entity and I start, so I've allocated some number of, the UI is a little busted.

1133
01:00:18.712 --> 01:00:20.474
<v SPEAKER_00>Did you see that red thing pop in here?

1134
01:00:23.242 --> 01:00:24.122
<v SPEAKER_00> And so that's the free list.

1135
01:00:24.242 --> 01:00:29.064
<v SPEAKER_00>And then if I start allocating again, it'll pop it off, stuff like that.

1136
01:00:29.125 --> 01:00:31.666
<v SPEAKER_00>So hopefully, it's kind of a lame visualization, I know.

1137
01:00:32.986 --> 01:00:34.587
<v SPEAKER_00>I did it yesterday.

1138
01:00:35.528 --> 01:00:36.768
<v SPEAKER_00>So yeah.

1139
01:00:37.369 --> 01:00:38.029
<v SPEAKER_00>Yeah, right here.

1140
01:00:42.131 --> 01:00:47.094
<v SPEAKER_02>So my question is, when you're showing the diagnostic, you've got those three arenas.

1141
01:00:49.155 --> 01:00:51.416
<v SPEAKER_02>And generally, I would think code shouldn't know

1142
01:00:53.450 --> 01:00:55.112
<v SPEAKER_02> So I think, um,

1143
01:01:11.400 --> 01:01:13.220
<v SPEAKER_00>I think many of those kinds of principles,

1144
01:01:13.240 --> 01:01:17.321
<v SPEAKER_00>like the object-oriented style view of encapsulation and not having people access things,

1145
01:01:17.401 --> 01:01:19.922
<v SPEAKER_00>like having people interact with this interface,

1146
01:01:20.382 --> 01:01:22.202
<v SPEAKER_00>I think it kind of makes sense,

1147
01:01:22.242 --> 01:01:25.023
<v SPEAKER_00>but only at an organizational boundary level.

1148
01:01:25.063 --> 01:01:27.944
<v SPEAKER_00>It's true at some granularity, but it's also false at another granularity.

1149
01:01:28.324 --> 01:01:29.864
<v SPEAKER_00>And so with the projects that I work on,

1150
01:01:29.884 --> 01:01:34.105
<v SPEAKER_00>the way that I'll try to organize things is one person will control an important layer,

1151
01:01:34.905 --> 01:01:37.546
<v SPEAKER_00>and that layer will be in charge of its memory allocation.

1152
01:01:38.667 --> 01:01:43.854
<v SPEAKER_00> But you'd want that layer to be able to be instantiated independently from other layers.

1153
01:01:44.355 --> 01:01:46.598
<v SPEAKER_00>And so anyone working inside that layer will have to know,

1154
01:01:47.379 --> 01:01:48.801
<v SPEAKER_00>here's where the arenas are,

1155
01:01:48.841 --> 01:01:50.523
<v SPEAKER_00>here's how I allocate things when I need them,

1156
01:01:50.563 --> 01:01:51.204
<v SPEAKER_00>that kind of thing.

1157
01:01:51.765 --> 01:01:53.087
<v SPEAKER_00>And then anyone outside of that

1158
01:01:54.028 --> 01:01:56.209
<v SPEAKER_00> They'll construct their own arenas for their own purposes.

1159
01:01:57.689 --> 01:02:00.690
<v SPEAKER_00>But it's going to be at a much less granular level than I think what

1160
01:02:00.770 --> 01:02:02.091
<v SPEAKER_00>object-oriented programming leads you to,

1161
01:02:02.131 --> 01:02:06.472
<v SPEAKER_00>where it's like every possible little thing just is that exact principle,

1162
01:02:06.492 --> 01:02:08.793
<v SPEAKER_00>where it's like nobody can talk about any details at all.

1163
01:02:11.614 --> 01:02:16.716
<v SPEAKER_00>And I think that just has, I found that to actually work pretty well when people

1164
01:02:18.126 --> 01:02:23.188
<v SPEAKER_00> work inside of these, like, larger layers than, like, the very granular little objects that you find.

1165
01:02:23.348 --> 01:02:24.708
<v SPEAKER_00>So hopefully that makes some sense.

1166
01:02:25.168 --> 01:02:33.011
<v SPEAKER_02>Yeah, but... Yeah, you can do module.

1167
01:02:37.592 --> 01:02:38.253
<v SPEAKER_00>Yeah, yeah.

1168
01:02:38.333 --> 01:02:39.033
<v SPEAKER_00>So, yeah, it's like...

1169
01:02:40.091 --> 01:02:40.491
<v SPEAKER_00>I try to,

1170
01:02:40.991 --> 01:02:44.853
<v SPEAKER_00>it's hard to talk about because like most rules of thumb about that kind of thing,

1171
01:02:45.313 --> 01:02:47.473
<v SPEAKER_00>like the granularity of a module is not very clear.

1172
01:02:47.734 --> 01:02:50.054
<v SPEAKER_00>And so people will think they're making a module,

1173
01:02:50.074 --> 01:02:51.595
<v SPEAKER_00>but in someone else's terminology,

1174
01:02:51.615 --> 01:02:52.335
<v SPEAKER_00>they're making like,

1175
01:02:52.935 --> 01:02:53.255
<v SPEAKER_00>I don't know,

1176
01:02:53.275 --> 01:02:54.856
<v SPEAKER_00>like a tiny little object or something.

1177
01:02:55.316 --> 01:02:56.617
<v SPEAKER_00>And those two things are not equivalent.

1178
01:02:56.637 --> 01:03:00.418
<v SPEAKER_00>So if you adopt the same rules at both granularities, it like leads to this kind of big mess.

1179
01:03:01.118 --> 01:03:02.739
<v SPEAKER_00> some granularity, I think what you're saying is true.

1180
01:03:02.779 --> 01:03:06.502
<v SPEAKER_00>Like, inside of this layer, it organizes its memory management plan.

1181
01:03:07.183 --> 01:03:10.365
<v SPEAKER_00>And everyone outside of that, like, they're not tackling that same problem.

1182
01:03:10.405 --> 01:03:12.127
<v SPEAKER_00>If they were, they'd be in that layer, right?

1183
01:03:12.147 --> 01:03:19.072
<v SPEAKER_00>Hopefully that makes some amount of sense, but... Yes, thank you.

1184
01:03:19.412 --> 01:03:19.512
<v SPEAKER_00>Yep.

1185
01:03:19.552 --> 01:03:20.633
<v SPEAKER_00>Oh, I forgot to record my screen.

1186
01:03:21.254 --> 01:03:21.474
<v SPEAKER_00>Sorry.

1187
01:03:21.974 --> 01:03:25.297
<v SPEAKER_01>You're having your free list.

1188
01:03:25.717 --> 01:03:25.857
<v SPEAKER_00>Yep.

1189
01:03:25.877 --> 01:03:28.519
<v SPEAKER_01>And you're adding to it because you've created some things.

1190
01:03:28.880 --> 01:03:29.000
<v SPEAKER_00>Mm-hmm.

1191
01:03:41.028 --> 01:03:43.889
<v SPEAKER_00> In the case of the name allocator or just in general?

1192
01:03:44.189 --> 01:03:44.529
<v SPEAKER_00>I see.

1193
01:03:46.049 --> 01:03:46.230
<v SPEAKER_00>Right.

1194
01:03:46.470 --> 01:03:46.710
<v SPEAKER_00>Yeah.

1195
01:03:46.750 --> 01:03:51.091
<v SPEAKER_00>So I think in the case of the name, you could have, like, for example, there are 56 bytes of payload.

1196
01:03:51.211 --> 01:03:53.031
<v SPEAKER_00>You could have a 16-byte string.

1197
01:03:53.512 --> 01:03:57.253
<v SPEAKER_00>And in that case, you would just grab whatever, like, you just fit to that granularity.

1198
01:03:57.633 --> 01:04:02.494
<v SPEAKER_00>But the point would be that you would have a strategy for different granularities that you want.

1199
01:04:02.774 --> 01:04:03.875
<v SPEAKER_00>So if you did have smaller sizes,

1200
01:04:03.895 --> 01:04:07.056
<v SPEAKER_00>like you did have a ton of 16-byte strings that you were worried about,

1201
01:04:07.536 --> 01:04:09.657
<v SPEAKER_00>then you would probably have a 16-byte payload,

1202
01:04:09.757 --> 01:04:11.318
<v SPEAKER_00>or I don't know what it would be,

1203
01:04:11.338 --> 01:04:14.980
<v SPEAKER_00>24-byte payload of free lists,

1204
01:04:15.140 --> 01:04:18.581
<v SPEAKER_00>as well as a 64-byte if you expect some number of larger ones.

1205
01:04:19.061 --> 01:04:19.782
<v SPEAKER_00>Or maybe you also have 1,024.

1206
01:04:24.024 --> 01:04:27.187
<v SPEAKER_00>I'm trying to keep the first eight bytes as the pointer in my head,

1207
01:04:27.227 --> 01:04:31.651
<v SPEAKER_00>but the point is you can have various sizes of payload and multiple free lists for

1208
01:04:31.711 --> 01:04:33.273
<v SPEAKER_00>each sort of granularity that you want.

1209
01:04:33.533 --> 01:04:34.353
<v SPEAKER_00>And then at some point,

1210
01:04:35.566 --> 01:04:36.246
<v SPEAKER_00>Worth mentioning,

1211
01:04:36.346 --> 01:04:37.447
<v SPEAKER_00>I didn't get into this in the talk,

1212
01:04:37.467 --> 01:04:39.988
<v SPEAKER_00>but with the virtual address space reservation,

1213
01:04:41.549 --> 01:04:43.730
<v SPEAKER_00>the granularity that that works at is like a page size.

1214
01:04:43.890 --> 01:04:49.972
<v SPEAKER_00>So the generic address space allocator that the operating system provides you works at page granularity.

1215
01:04:50.272 --> 01:04:55.054
<v SPEAKER_00>So at least you have to reserve four kilobytes.

1216
01:04:55.995 --> 01:04:58.756
<v SPEAKER_00>And then that's also the granularity that pages commit.

1217
01:04:58.796 --> 01:05:02.237
<v SPEAKER_00>Now, page size can vary, obviously, but generally it's going to be 4K today.

1218
01:05:04.400 --> 01:05:04.947
<v SPEAKER_00> can change.

1219
01:05:07.540 --> 01:05:09.581
<v SPEAKER_00> You're allocating a page granularity.

1220
01:05:09.861 --> 01:05:14.422
<v SPEAKER_00>So if you have, for example, a bunch of strings that you expect to be much larger.

1221
01:05:14.442 --> 01:05:18.223
<v SPEAKER_00>You have strings that are like, I don't know, this is the contents of some file or something like that.

1222
01:05:18.643 --> 01:05:21.864
<v SPEAKER_00>And you expect this thing to be at least 4K, in many cases, over.

1223
01:05:22.184 --> 01:05:25.265
<v SPEAKER_00>Then it's like, that's the case where you wanted the arena.

1224
01:05:25.285 --> 01:05:27.706
<v SPEAKER_00>You just have an arena per thing in the free list instead.

1225
01:05:28.206 --> 01:05:32.448
<v SPEAKER_00>And then you don't need to do this slicing up individual pieces of an arena anymore.

1226
01:05:32.468 --> 01:05:35.588
<v SPEAKER_00>You just have one for the file or whatever you were working with.

1227
01:05:35.709 --> 01:05:36.969
<v SPEAKER_00>So does that make sense?

1228
01:05:37.927 --> 01:05:38.067
<v SPEAKER_00> Cool.

1229
01:05:38.187 --> 01:05:38.447
<v SPEAKER_00>Yep.

1230
01:05:39.968 --> 01:05:40.448
<v SPEAKER_00>Uh, right.

1231
01:05:40.628 --> 01:05:40.949
<v SPEAKER_00>Oh, okay.

1232
01:05:41.089 --> 01:05:42.810
<v SPEAKER_00>I don't know who's doing the mic.

1233
01:05:43.530 --> 01:05:43.770
<v SPEAKER_00>Right there.

1234
01:05:43.850 --> 01:05:43.930
<v SPEAKER_00>Okay.

1235
01:05:44.010 --> 01:05:54.456
<v SPEAKER_00>Uh, so, uh, I noticed in your, uh, statistics, uh, you have, uh, good, uh, memory committed.

1236
01:05:54.476 --> 01:05:54.576
<v SPEAKER_00>Yep.

1237
01:05:54.596 --> 01:05:59.018
<v SPEAKER_00>Uh, I noticed the memory committed was important.

1238
01:05:59.038 --> 01:05:59.078
<v SPEAKER_00>Uh...

1239
01:06:00.896 --> 01:06:02.277
<v SPEAKER_00> Oh, shoot, maybe I screwed it up.

1240
01:06:02.317 --> 01:06:03.057
<v SPEAKER_00>It might be increments of 4K.

1241
01:06:03.077 --> 01:06:03.357
<v SPEAKER_00>Sorry.

1242
01:06:03.417 --> 01:06:04.517
<v SPEAKER_00>Yeah, yeah.

1243
01:06:04.698 --> 01:06:06.478
<v SPEAKER_00>I probably just did the wrong divide there.

1244
01:06:06.558 --> 01:06:07.259
<v SPEAKER_00>But yeah, so.

1245
01:06:08.019 --> 01:06:08.539
<v SPEAKER_00>Yeah, for sure.

1246
01:06:08.579 --> 01:06:10.160
<v SPEAKER_00>Yeah, you do commit in page granularity.

1247
01:06:10.180 --> 01:06:11.600
<v SPEAKER_00>Like, you can't commit smaller than a page.

1248
01:06:11.620 --> 01:06:17.863
<v SPEAKER_02>So when you grow an arena,

1249
01:06:17.883 --> 01:06:18.923
<v SPEAKER_02>do you ever have to worry about,

1250
01:06:19.103 --> 01:06:19.243
<v SPEAKER_02>like,

1251
01:06:19.263 --> 01:06:21.364
<v SPEAKER_02>the data across from the old part of the arena to the new part of the arena?

1252
01:06:21.384 --> 01:06:29.548
<v SPEAKER_02>Like, do you ever have to worry about boundaries between the data allocator and the operating system?

1253
01:06:32.947 --> 01:06:37.390
<v SPEAKER_00> Yeah, so I guess for the video, I should repeat the questions, actually.

1254
01:06:37.710 --> 01:06:42.412
<v SPEAKER_00>So the question was, do you have to worry about boundaries between, I would assume, pages?

1255
01:06:42.432 --> 01:06:45.074
<v SPEAKER_00>Yeah, so pages on an arena as an arena grows.

1256
01:06:45.754 --> 01:06:48.976
<v SPEAKER_00>And the way that that will work,

1257
01:06:49.036 --> 01:06:49.356
<v SPEAKER_00>so this is,

1258
01:06:49.917 --> 01:06:50.817
<v SPEAKER_00>to be very precise,

1259
01:06:50.857 --> 01:06:53.819
<v SPEAKER_00>this is about the reserve large virtual address space,

1260
01:06:53.959 --> 01:06:55.000
<v SPEAKER_00>commit pages as needed.

1261
01:06:55.240 --> 01:06:56.841
<v SPEAKER_00>Do you have to worry about things in between pages?

1262
01:06:57.501 --> 01:07:02.987
<v SPEAKER_00> And inside of the perspective of your process, all of those things are contiguous in address space.

1263
01:07:03.047 --> 01:07:06.891
<v SPEAKER_00>So if you access the first 32 bytes at the end of a page and then 32 bytes after

1264
01:07:06.951 --> 01:07:07.671
<v SPEAKER_00>that page boundary,

1265
01:07:08.032 --> 01:07:10.514
<v SPEAKER_00>that's all going to be mapped by the hardware.

1266
01:07:10.534 --> 01:07:14.979
<v SPEAKER_00>It might be in different places in physical memory, but it looks to you like it's contiguous

1267
01:07:16.360 --> 01:07:19.781
<v SPEAKER_00> your memory, like your virtual address space, those things are contiguous.

1268
01:07:20.581 --> 01:07:23.041
<v SPEAKER_00>Now what you do have to care about is if you do the chaining approach,

1269
01:07:23.541 --> 01:07:26.062
<v SPEAKER_00>then that's like discontinuous in your address space.

1270
01:07:26.102 --> 01:07:27.442
<v SPEAKER_00>And so that's when you actually have to care.

1271
01:07:28.142 --> 01:07:30.763
<v SPEAKER_00>That's one reason why linked lists work very well with arenas,

1272
01:07:31.823 --> 01:07:34.243
<v SPEAKER_00>despite the memes and everything about linked lists.

1273
01:07:34.343 --> 01:07:38.164
<v SPEAKER_00>But in a case like that,

1274
01:07:38.224 --> 01:07:40.584
<v SPEAKER_00>if you write your code to just work on discontinuous boundaries,

1275
01:07:40.724 --> 01:07:42.045
<v SPEAKER_00>kind of like what I did with the names,

1276
01:07:42.625 --> 01:07:43.185
<v SPEAKER_00>then you

1277
01:07:44.926 --> 01:07:49.108
<v SPEAKER_00> Then you write your code that way, and it works with this continuity of your storage.

1278
01:07:50.369 --> 01:07:54.351
<v SPEAKER_00>But yeah, in the case of reserve and commit pages as needed, that's all contiguous in your address space.

1279
01:07:54.371 --> 01:07:55.651
<v SPEAKER_00>You don't have to think about that.

1280
01:07:55.671 --> 01:07:56.692
<v SPEAKER_02>So just to be clear,

1281
01:07:56.712 --> 01:08:02.494
<v SPEAKER_02>it's like if you needed to grow a string allocating to the chunk in your chunk list,

1282
01:08:02.514 --> 01:08:03.555
you would copy the string

1283
01:08:06.221 --> 01:08:07.962
<v SPEAKER_00> Yeah, because those chunks are discontinuous.

1284
01:08:08.083 --> 01:08:09.163
<v SPEAKER_00>So I'll push a new chunk,

1285
01:08:09.303 --> 01:08:11.245
<v SPEAKER_00>or I'll grab a new chunk from the free list or whatever,

1286
01:08:11.565 --> 01:08:14.688
<v SPEAKER_00>which could be in a completely different spot than the first chunk I had or

1287
01:08:14.708 --> 01:08:16.009
<v SPEAKER_00>something if I was adding to the string.

1288
01:08:16.449 --> 01:08:17.190
<v SPEAKER_00>And so in that case,

1289
01:08:17.210 --> 01:08:19.411
<v SPEAKER_00>I would grab the new characters that I have to copy,

1290
01:08:20.152 --> 01:08:21.173
<v SPEAKER_00>copy them into that chunk,

1291
01:08:21.373 --> 01:08:23.815
<v SPEAKER_00>and then now my string is sort of spread across multiple things.

1292
01:08:23.855 --> 01:08:25.436
<v SPEAKER_00>And if I ever want to treat it contiguously,

1293
01:08:25.896 --> 01:08:27.357
<v SPEAKER_00>then you can make a decision of just like,

1294
01:08:28.338 --> 01:08:30.840
<v SPEAKER_00>you can either have a complex allocator to try to keep it contiguous,

1295
01:08:31.080 --> 01:08:34.903
<v SPEAKER_00>or you can just pay the mem copy cost when you need the string as a contiguous

1296
01:08:34.923 --> 01:08:35.484
<v SPEAKER_00>string or whatever.

1297
01:08:36.084 --> 01:08:37.485
<v SPEAKER_00> So, yep?

1298
01:08:45.289 --> 01:08:45.549
<v SPEAKER_01>Yes,

1299
01:08:45.589 --> 01:08:46.249
<v SPEAKER_01>the question is,

1300
01:08:46.689 --> 01:08:48.770
<v SPEAKER_01>in this stuff,

1301
01:08:49.031 --> 01:08:53.933
<v SPEAKER_01>you have gone part of the way towards a fully sort of malloc generic allocator.

1302
01:08:54.653 --> 01:09:00.536
<v SPEAKER_01>How far have you ever had to go to make something equivalent to malloc in your arena systems?

1303
01:09:01.997 --> 01:09:04.678
<v SPEAKER_00>Yeah, so, question for video.

1304
01:09:07.540 --> 01:09:11.382
<v SPEAKER_00> I've shown one step towards a general purpose allocator just with these free lists.

1305
01:09:11.802 --> 01:09:14.964
<v SPEAKER_00>How far have I had to go to get closer?

1306
01:09:15.204 --> 01:09:18.386
<v SPEAKER_00>Have I ever had to go the full length to a full malloc invitation or something like that?

1307
01:09:20.563 --> 01:09:24.405
<v SPEAKER_00> Yeah, so the answer is, like, I've never had to do the full heap allocation thing.

1308
01:09:24.625 --> 01:09:28.366
<v SPEAKER_00>Now, on top of an arena, you obviously could if you wanted to.

1309
01:09:28.907 --> 01:09:33.449
<v SPEAKER_00>Usually you know way more about your problem than the implementers of malloc do about your problem.

1310
01:09:33.489 --> 01:09:34.889
<v SPEAKER_00>So the thing about malloc,

1311
01:09:35.789 --> 01:09:38.491
<v SPEAKER_00>and this is a story that I was considering putting in the talk,

1312
01:09:38.511 --> 01:09:39.471
<v SPEAKER_00>but I just omitted it.

1313
01:09:40.471 --> 01:09:42.152
<v SPEAKER_00>I wrote an arena once and someone told me,

1314
01:09:42.172 --> 01:09:43.493
<v SPEAKER_00>and I was using it,

1315
01:09:43.513 --> 01:09:43.933
<v SPEAKER_00>and they were like,

1316
01:09:43.953 --> 01:09:45.554
<v SPEAKER_00>do you think you could write a better allocator than

1317
01:09:46.534 --> 01:09:47.694
<v SPEAKER_00>malloc implementation,

1318
01:09:47.814 --> 01:09:49.375
<v SPEAKER_00>like people writing on glibc,

1319
01:09:49.695 --> 01:09:51.956
<v SPEAKER_00>people working on glibc's implementation of malloc or something.

1320
01:09:52.576 --> 01:09:55.537
<v SPEAKER_00>And it's kind of a weird question because it's a different problem.

1321
01:09:55.617 --> 01:09:57.638
<v SPEAKER_00>Writing an arena is much simpler.

1322
01:09:57.678 --> 01:10:01.659
<v SPEAKER_00>Writing a free list for data you know about and given your expected constraints on

1323
01:10:01.699 --> 01:10:04.020
<v SPEAKER_00>your problem is dramatically simpler than an arena.

1324
01:10:04.060 --> 01:10:07.681
<v SPEAKER_00>So I've never had to even go to the full generic thing because I always know more about my problem.

1325
01:10:08.881 --> 01:10:10.682
<v SPEAKER_00>Now, the most complex one that I've done

1326
01:10:11.707 --> 01:10:14.148
<v SPEAKER_00>is probably that Atlas allocator thing that I showed,

1327
01:10:14.508 --> 01:10:19.890
<v SPEAKER_00>or is allocating variably sized chunks that overlap with each other out of a two

1328
01:10:19.910 --> 01:10:20.711
<v SPEAKER_00>dimensional space.

1329
01:10:21.571 --> 01:10:23.212
<v SPEAKER_00>That's probably the most complex thing I've done.

1330
01:10:23.252 --> 01:10:29.214
<v SPEAKER_00>And it's kind of weird because you're using CPU memory to sort of track portions of

1331
01:10:29.234 --> 01:10:30.815
<v SPEAKER_00>a virtual texture space.

1332
01:10:30.835 --> 01:10:36.857
<v SPEAKER_00>But the same principle would apply to dividing up CPU memory the same way.

1333
01:10:36.897 --> 01:10:38.678
<v SPEAKER_00>That's the most complicated I've ever had to do.

1334
01:10:39.518 --> 01:10:41.439
<v SPEAKER_00>If I ever need something more complicated,

1335
01:10:41.459 --> 01:10:44.201
<v SPEAKER_00>like where I truly have this sort of web of lifetimes concept,

1336
01:10:44.721 --> 01:10:50.605
<v SPEAKER_00>then usually I'm only worrying about things that are going to cost way more than 4K anyways,

1337
01:10:50.625 --> 01:10:53.306
<v SPEAKER_00>in which case I'll just use an arena per thing that I need.

1338
01:10:53.326 --> 01:10:53.366
<v SPEAKER_00>So.

1339
01:10:54.407 --> 01:11:00.630
<v SPEAKER_02>Just so that way everyone in the audience knows, my name is Vincent.

1340
01:11:00.790 --> 01:11:02.371
<v SPEAKER_02>I'm helping kind of coordinate a little bit of this.

1341
01:11:02.411 --> 01:11:04.973
<v SPEAKER_02>If you could give the mic back to me when the answer is right,

1342
01:11:05.393 --> 01:11:06.754
<v SPEAKER_02>when the answer is given,

1343
01:11:06.774 --> 01:11:08.075
<v SPEAKER_02>I would be happy.

1344
01:11:15.230 --> 01:11:15.551
 Thank you.

1345
01:11:15.571 --> 01:11:16.171
Oh, thanks.

1346
01:11:16.291 --> 01:11:16.471
Okay.

1347
01:11:16.491 --> 01:11:19.114
Yeah, it's sort of like...

1348
01:11:35.896 --> 01:11:38.719
<v SPEAKER_00> There's no, really what it is is a rectangle on the screen.

1349
01:11:38.739 --> 01:11:40.080
<v SPEAKER_00>There's no data to show there,

1350
01:11:40.140 --> 01:11:41.321
<v SPEAKER_00>but the only thing,

1351
01:11:41.341 --> 01:11:45.705
<v SPEAKER_00>it sort of is just visually representing all of the committed space.

1352
01:11:45.725 --> 01:11:48.327
<v SPEAKER_00>And so when I position those red spots in the free list,

1353
01:11:49.068 --> 01:11:52.151
<v SPEAKER_00>I'm calculating the percentage offset given the base address

1354
01:11:52.831 --> 01:11:54.392
<v SPEAKER_00>I'll take the address of the free list node,

1355
01:11:54.713 --> 01:11:57.094
<v SPEAKER_00>and then take it from the base address of the arena,

1356
01:11:58.075 --> 01:12:01.178
<v SPEAKER_00>and then do a divide between that and the committed size,

1357
01:12:01.298 --> 01:12:03.399
<v SPEAKER_00>and then use that to position it on the UI rectangle.

1358
01:12:03.439 --> 01:12:06.582
<v SPEAKER_00>So there's not really that much to the blue rectangles.

1359
01:12:06.602 --> 01:12:07.723
<v SPEAKER_00>They're just blue rectangles.

1360
01:12:07.783 --> 01:12:11.946
<v SPEAKER_00>But that size is used for the positioning of the free list nodes.

1361
01:12:11.966 --> 01:12:12.006
<v SPEAKER_00>OK.

1362
01:12:12.026 --> 01:12:16.790
<v SPEAKER_02>So it's not showing you this is the start address of the arena.

1363
01:12:16.810 --> 01:12:20.412
This is the end address of the arena.

1364
01:12:20.432 --> 01:12:20.612
Right.

1365
01:12:21.373 --> 01:12:21.493
Yep.

1366
01:12:21.673 --> 01:12:22.194
It's just committed.

1367
01:12:24.141 --> 01:12:25.722
So my second question was,

1368
01:12:26.562 --> 01:12:29.823
<v SPEAKER_02>I'm thinking about this in terms of an entity component system,

1369
01:12:30.324 --> 01:12:31.364
<v SPEAKER_02>where in an ECS,

1370
01:12:31.644 --> 01:12:33.045
<v SPEAKER_02>you've got entities,

1371
01:12:33.185 --> 01:12:34.965
<v SPEAKER_02>you attach components to an entity,

1372
01:12:34.985 --> 01:12:39.187
<v SPEAKER_02>which is a unique identifier that's not necessarily a pointer,

1373
01:12:39.387 --> 01:12:41.228
<v SPEAKER_02>just an integer.

1374
01:12:41.488 --> 01:12:43.509
<v SPEAKER_02>But in contrast,

1375
01:12:44.009 --> 01:12:45.290
<v SPEAKER_02>with the arena,

1376
01:12:45.310 --> 01:12:50.752
<v SPEAKER_02>it seems like instead of having an entity that's consistent for whatever lifetime,

1377
01:12:51.312 --> 01:12:52.793
<v SPEAKER_02>you keep a pointer consistent.

1378
01:12:54.747 --> 01:12:54.907
<v SPEAKER_00>Yeah,

1379
01:12:55.087 --> 01:12:55.687
<v SPEAKER_00>that's generally,

1380
01:12:56.328 --> 01:12:57.928
<v SPEAKER_00>I think that's a very useful approach,

1381
01:12:57.968 --> 01:12:59.749
<v SPEAKER_00>and that's the way I usually do it,

1382
01:12:59.789 --> 01:13:00.289
<v SPEAKER_00>is I'll keep,

1383
01:13:01.009 --> 01:13:01.609
<v SPEAKER_00>I'll try to keep,

1384
01:13:01.709 --> 01:13:01.889
<v SPEAKER_00>like,

1385
01:13:02.910 --> 01:13:05.471
<v SPEAKER_00>pointers consistent as much as I can.

1386
01:13:05.611 --> 01:13:08.972
<v SPEAKER_00>So with entities, like, if there are empty slots, I'll just iterate over them.

1387
01:13:09.052 --> 01:13:10.612
<v SPEAKER_00>But, yeah.

1388
01:13:10.773 --> 01:13:12.553
<v SPEAKER_00>But I don't know if that was, like, the heart of the question, so.

1389
01:13:12.933 --> 01:13:14.674
<v SPEAKER_02>No, that definitely would have come.

1390
01:13:14.734 --> 01:13:14.854
<v SPEAKER_02>Okay.

1391
01:13:14.934 --> 01:13:19.996
<v SPEAKER_02>And then, so the follow-up to that is, for use cases like this, where you could potentially

1392
01:13:38.929 --> 01:13:41.591
<v SPEAKER_00>So are you imagining,

1393
01:13:41.711 --> 01:13:43.672
<v SPEAKER_00>just to understand the question a little bit more,

1394
01:13:43.712 --> 01:13:47.294
<v SPEAKER_00>are you imagining that every type of component would end up on the same arena?

1395
01:13:48.510 --> 01:13:49.011
<v SPEAKER_00> OK, yeah.

1396
01:13:49.051 --> 01:13:50.452
<v SPEAKER_00>So you could do that.

1397
01:13:50.652 --> 01:13:52.153
<v SPEAKER_00>But I think in a case like that,

1398
01:13:52.193 --> 01:13:55.956
<v SPEAKER_00>if I had a bunch of fixed size things that I really wanted to be able to quickly

1399
01:13:55.996 --> 01:14:00.200
<v SPEAKER_00>iterate over them and have the actual memory accesses be very linear in memory,

1400
01:14:01.060 --> 01:14:03.302
<v SPEAKER_00>then I would just have a different arena for the different components.

1401
01:14:04.223 --> 01:14:06.284
<v SPEAKER_00>And then you might still have a free list through them if you want.

1402
01:14:06.344 --> 01:14:11.989
<v SPEAKER_00>But then you sort of are trying to keep things that are like

1403
01:14:14.551 --> 01:14:17.272
<v SPEAKER_00> alike things together, basically, in memory, in that kind of a case.

1404
01:14:18.272 --> 01:14:18.952
<v SPEAKER_00>So, yeah.

1405
01:14:19.732 --> 01:14:25.753
<v SPEAKER_02>Yeah, so my question is about lifetimes.

1406
01:14:26.193 --> 01:14:32.374
<v SPEAKER_02>So you talked about arenas have lifetimes, and that's kind of part of the thought process.

1407
01:14:33.075 --> 01:14:38.636
<v SPEAKER_02>But then you also showed examples of a query arena, and then you have a string arena.

1408
01:14:38.656 --> 01:14:40.516
<v SPEAKER_02>So my question is, basically,

1409
01:14:44.642 --> 01:14:47.765
<v SPEAKER_02> the purpose of the arena?

1410
01:14:48.405 --> 01:14:53.409
<v SPEAKER_02>Do you think about the use case of the arena and then the lifetime is kind of like

1411
01:14:54.050 --> 01:14:57.833
<v SPEAKER_02>an after effect or the consequence of the purpose of the arena?

1412
01:14:58.033 --> 01:15:03.657
<v SPEAKER_02>Or is the lifetime always the primary thought process when you think about what you

1413
01:15:03.677 --> 01:15:04.198
<v SPEAKER_02>want to make,

1414
01:15:04.318 --> 01:15:05.559
<v SPEAKER_02>what you want to use?

1415
01:15:06.485 --> 01:15:07.926
<v SPEAKER_00> Yeah, sure.

1416
01:15:08.186 --> 01:15:12.648
<v SPEAKER_00>The question was, do you consider lifetimes as sort of an afterthought?

1417
01:15:12.668 --> 01:15:19.011
<v SPEAKER_00>There are a few arenas in the demo that I had where it's like a few arenas that are

1418
01:15:19.031 --> 01:15:19.211
<v SPEAKER_00>sort of,

1419
01:15:19.231 --> 01:15:20.532
<v SPEAKER_00>they all kind of have the same lifetime.

1420
01:15:20.572 --> 01:15:21.652
<v SPEAKER_00>They're all used for the same thing.

1421
01:15:21.712 --> 01:15:25.674
<v SPEAKER_00>So do arenas truly correspond one-to-one with lifetimes?

1422
01:15:26.715 --> 01:15:31.037
<v SPEAKER_00>Or is that just kind of like an afterthought to what the arenas are used for?

1423
01:15:31.717 --> 01:15:34.679
<v SPEAKER_00>And I think my perspective on it is that it's like,

1424
01:15:35.359 --> 01:15:36.520
<v SPEAKER_00> It's a constraint solving problem.

1425
01:15:37.020 --> 01:15:40.903
<v SPEAKER_00>So you try to bundle lifetimes as much as you can together.

1426
01:15:42.504 --> 01:15:46.567
<v SPEAKER_00>Organizing three arenas with identical lifetimes is not that much more complicated than doing one.

1427
01:15:47.887 --> 01:15:50.469
<v SPEAKER_00>But I wanted to keep, for example, all the entities contiguous.

1428
01:15:50.929 --> 01:15:57.934
<v SPEAKER_00>Oh, and I suppose another thing was I wanted to independently free the name arena.

1429
01:15:57.954 --> 01:16:00.136
<v SPEAKER_00>So there are these different constraints that work their way into the picture.

1430
01:16:00.876 --> 01:16:03.701
<v SPEAKER_00>So it's not strictly like you only have lifetimes,

1431
01:16:03.721 --> 01:16:05.804
<v SPEAKER_00>but there are also other constraints you have to be concerned about.

1432
01:16:05.864 --> 01:16:07.767
<v SPEAKER_00>Like, do you want these things to be contiguous?

1433
01:16:07.787 --> 01:16:09.871
<v SPEAKER_00>Do you want multiple things in the arena or just one?

1434
01:16:10.372 --> 01:16:10.752
<v SPEAKER_00>So on.

1435
01:16:11.113 --> 01:16:13.757
<v SPEAKER_00>So yeah, it's not like...

1436
01:16:14.787 --> 01:16:21.592
<v SPEAKER_00> There's no unifying thing there, but the arena gives you the tool to bundle lifetimes when you can.

1437
01:16:22.012 --> 01:16:25.875
<v SPEAKER_00>And so that's what leads to the just dramatic reduction in how many lifetimes you

1438
01:16:25.895 --> 01:16:26.676
<v SPEAKER_00>actually have to think about.

1439
01:16:27.216 --> 01:16:27.957
<v SPEAKER_00>Because in this case,

1440
01:16:27.997 --> 01:16:32.040
<v SPEAKER_00>it's like instead of having thousands of lifetimes for different entities,

1441
01:16:32.160 --> 01:16:32.340
<v SPEAKER_00>I mean,

1442
01:16:32.360 --> 01:16:33.001
<v SPEAKER_00>I kind of do,

1443
01:16:33.041 --> 01:16:36.583
<v SPEAKER_00>but they're all scoped by these three large lifetimes that I just set up once and

1444
01:16:36.603 --> 01:16:37.184
<v SPEAKER_00>then I forget about it.

1445
01:16:37.404 --> 01:16:39.366
<v SPEAKER_00>So hopefully that answers the question.

1446
01:16:51.050 --> 01:16:51.310
<v SPEAKER_02> Yep.

1447
01:16:51.330 --> 01:16:51.510
<v SPEAKER_02>Yep.

1448
01:17:23.812 --> 01:17:24.713
<v SPEAKER_02>hopefully work together,

1449
01:17:24.753 --> 01:17:26.254
<v SPEAKER_02>but you have this logic,

1450
01:17:26.335 --> 01:17:26.515
<v SPEAKER_02>right,

1451
01:17:26.555 --> 01:17:26.995
<v SPEAKER_02>for arenas,

1452
01:17:27.055 --> 01:17:28.597
<v SPEAKER_02>and you have the point of the arena.

1453
01:17:28.997 --> 01:17:31.519
<v SPEAKER_02>Is there some portion of that that can be standardized,

1454
01:17:31.539 --> 01:17:35.023
<v SPEAKER_02>so all these things that want to talk about arenas can actually talk about them

1455
01:17:35.043 --> 01:17:36.924
<v SPEAKER_02>past the standard library style,

1456
01:17:36.984 --> 01:17:37.665
<v SPEAKER_02>not free,

1457
01:17:37.705 --> 01:17:37.865
<v SPEAKER_02>right?

1458
01:17:37.945 --> 01:17:42.870
<v SPEAKER_02>Is there a standard set of, like, let me talk about arenas, this is the true, most boiled-down set

1459
01:17:45.071 --> 01:17:45.571
<v SPEAKER_00> Sure, yeah.

1460
01:17:45.771 --> 01:17:48.953
<v SPEAKER_00>So with the MetaDesk library,

1461
01:17:49.153 --> 01:17:53.875
<v SPEAKER_00>that was like our kind of approach at trying to make different arenas click in.

1462
01:17:53.895 --> 01:17:56.736
<v SPEAKER_00>Because we had code bases where we wanted to use MetaDesk,

1463
01:17:56.776 --> 01:18:00.658
<v SPEAKER_00>but we had arenas in those code bases that ideally we could just write all of our

1464
01:18:00.938 --> 01:18:03.459
<v SPEAKER_00>MetaDesk code passing our own arenas in.

1465
01:18:04.319 --> 01:18:06.480
<v SPEAKER_00>But if someone didn't have an arena and they just wanted to use MetaDesk,

1466
01:18:06.500 --> 01:18:08.561
<v SPEAKER_00>then maybe we just supply our own implementation or something like that.

1467
01:18:08.581 --> 01:18:12.203
<v SPEAKER_00>That was kind of our approach at like abstracting what we thought about of an arena

1468
01:18:13.323 --> 01:18:14.746
<v SPEAKER_00> in that problem space.

1469
01:18:14.826 --> 01:18:15.587
<v SPEAKER_00>And it kind of works,

1470
01:18:15.627 --> 01:18:20.415
<v SPEAKER_00>but you have to have a very similar interface to an arena to be able to plug into

1471
01:18:20.455 --> 01:18:20.836
<v SPEAKER_00>it at all.

1472
01:18:21.297 --> 01:18:25.844
<v SPEAKER_00>And so I think you basically hit the nail on the head, though, which is,

1473
01:18:27.458 --> 01:18:29.800
<v SPEAKER_00> In order for people to, you have to agree on something.

1474
01:18:30.141 --> 01:18:33.844
<v SPEAKER_00>If you want to include in a library that is written for an arena that you want to

1475
01:18:33.864 --> 01:18:34.825
<v SPEAKER_00>plug your own arena into,

1476
01:18:35.265 --> 01:18:37.707
<v SPEAKER_00>if they just have completely different ideas about what an arena is,

1477
01:18:38.188 --> 01:18:39.269
<v SPEAKER_00>then it's not going to work.

1478
01:18:39.949 --> 01:18:44.674
<v SPEAKER_00>So there does need to be some boiled down set of ideas that people would agree on

1479
01:18:44.814 --> 01:18:46.135
<v SPEAKER_00>if they want their code to click together.

1480
01:18:49.458 --> 01:18:49.898
<v SPEAKER_00> You could.

1481
01:18:50.099 --> 01:18:53.701
<v SPEAKER_00>10 people could get together and be like, this is the arena we're using everywhere.

1482
01:18:53.801 --> 01:18:58.344
<v SPEAKER_00>And you'll find that in code bases when people just define an arena in the base

1483
01:18:58.384 --> 01:19:02.087
<v SPEAKER_00>layer and then have layers stacking on top that can just write everything to an arena.

1484
01:19:04.468 --> 01:19:10.652
<v SPEAKER_00>Whether there's a push to make that wider than a single team or group of people, it's not up to me.

1485
01:19:11.853 --> 01:19:14.575
<v SPEAKER_00>But certainly, that is the nature of the problem.

1486
01:19:15.768 --> 01:19:15.908
<v SPEAKER_00>So,

1487
01:19:16.208 --> 01:19:16.348
<v SPEAKER_00>yeah,

1488
01:19:16.468 --> 01:19:16.569
<v SPEAKER_00>oh,

1489
01:19:16.649 --> 01:19:16.809
<v SPEAKER_00>yeah,

1490
01:19:16.909 --> 01:19:19.270
<v SPEAKER_00>and if you want,

1491
01:19:19.310 --> 01:19:19.470
<v SPEAKER_00>like,

1492
01:19:20.091 --> 01:19:25.334
<v SPEAKER_00>if C's standard library came with an arena and everyone happened to be happy with it,

1493
01:19:25.414 --> 01:19:26.214
<v SPEAKER_00>all the C programmers,

1494
01:19:26.234 --> 01:19:26.374
<v SPEAKER_00>like,

1495
01:19:26.434 --> 01:19:27.595
<v SPEAKER_00>put their differences aside,

1496
01:19:27.655 --> 01:19:27.795
<v SPEAKER_00>which,

1497
01:19:27.855 --> 01:19:28.035
<v SPEAKER_00>like,

1498
01:19:28.436 --> 01:19:28.696
<v SPEAKER_00>you know,

1499
01:19:28.896 --> 01:19:29.276
<v SPEAKER_00>forget it.

1500
01:19:29.716 --> 01:19:30.997
<v SPEAKER_00>But if that did happen,

1501
01:19:31.037 --> 01:19:31.217
<v SPEAKER_00>then,

1502
01:19:31.437 --> 01:19:31.658
<v SPEAKER_00>yes,

1503
01:19:31.698 --> 01:19:31.858
<v SPEAKER_00>like,

1504
01:19:31.938 --> 01:19:34.479
<v SPEAKER_00>everyone just could write to that arena the same way they write to malloc and free.

1505
01:19:38.182 --> 01:19:38.342
Hi.

1506
01:19:39.002 --> 01:19:39.262
<v SPEAKER_00>Hello.

1507
01:19:40.423 --> 01:19:41.183
<v SPEAKER_00>I forgot to record.

1508
01:19:41.343 --> 01:19:41.964
<v SPEAKER_00>Sorry.

1509
01:19:42.364 --> 01:19:42.804
<v SPEAKER_00>My screen.

1510
01:19:43.285 --> 01:19:43.625
<v SPEAKER_00>I'm sorry.

1511
01:19:44.022 --> 01:19:47.304
<v SPEAKER_02> This is the organizer speaking for the benefit of the camera.

1512
01:19:48.305 --> 01:19:50.846
<v SPEAKER_02>I just wanted to mention that we have about half an hour left.

1513
01:19:51.126 --> 01:19:51.406
<v SPEAKER_02>Oh, wow.

1514
01:19:51.467 --> 01:19:51.707
<v SPEAKER_02>All right.

1515
01:19:51.767 --> 01:19:53.788
<v SPEAKER_02>So if people want to keep asking questions, no problem.

1516
01:19:54.188 --> 01:19:58.031
<v SPEAKER_02>But let's imagine that for the benefit of future speakers who are going to be

1517
01:19:58.051 --> 01:19:58.411
<v SPEAKER_02>saying this,

1518
01:19:58.691 --> 01:20:02.913
<v SPEAKER_02>let's imagine you run out of questions and your master class is over and we're like

1519
01:20:03.274 --> 01:20:04.875
<v SPEAKER_02>half an hour early or 20 minutes.

1520
01:20:04.915 --> 01:20:06.035
<v SPEAKER_02>That's fine, right?

1521
01:20:06.095 --> 01:20:07.977
<v SPEAKER_02>More time to socialize, more time to go to lunch.

1522
01:20:07.997 --> 01:20:08.617
<v SPEAKER_02>You know what I mean?

1523
01:20:08.637 --> 01:20:10.158
<v SPEAKER_02>So I'm still seeing hands going up.

1524
01:20:10.278 --> 01:20:12.099
<v SPEAKER_02>And I also have a question.

1525
01:20:12.279 --> 01:20:13.080
<v SPEAKER_02>All right.

1526
01:20:13.380 --> 01:20:13.600
Sure.

1527
01:20:15.916 --> 01:20:21.901
<v SPEAKER_02> I'm using your arena-based memory strategies for my own software project.

1528
01:20:22.121 --> 01:20:24.663
<v SPEAKER_02>And it's funny because I'm running a terminal.

1529
01:20:25.144 --> 01:20:26.925
<v SPEAKER_02>People can go to terminal.quick.

1530
01:20:26.945 --> 01:20:27.726
<v SPEAKER_02>I love that domain.

1531
01:20:28.146 --> 01:20:31.289
<v SPEAKER_02>Terminal.quick, you can see kind of like gifs of my terminal project.

1532
01:20:31.409 --> 01:20:36.073
<v SPEAKER_02>And people who attend the AMI Boston will also be getting a beta of it later this month.

1533
01:20:36.293 --> 01:20:38.235
<v SPEAKER_02>So you can try this terminal project that I've written,

1534
01:20:38.575 --> 01:20:39.476
<v SPEAKER_02>this terminal emulator,

1535
01:20:39.576 --> 01:20:41.517
<v SPEAKER_02>using Ryan's complete arena-based system.

1536
01:20:41.798 --> 01:20:42.158
<v SPEAKER_02>It's amazing.

1537
01:20:47.722 --> 01:20:48.382
<v SPEAKER_02> It's native.

1538
01:20:48.763 --> 01:20:49.343
<v SPEAKER_02>It's fantastic.

1539
01:20:49.823 --> 01:20:52.505
<v SPEAKER_02>But it's not like there's zero problems.

1540
01:20:53.766 --> 01:20:58.209
<v SPEAKER_02>One issue that I have encountered is the issue of overlapping lifetimes.

1541
01:20:58.229 --> 01:21:01.191
<v SPEAKER_02>By accident, it's like, oh, it's lifetime.

1542
01:21:01.911 --> 01:21:03.492
<v SPEAKER_02>I'll live the other one.

1543
01:21:03.972 --> 01:21:06.774
<v SPEAKER_02>And I guess I don't know if you mentioned that in the lecture.

1544
01:21:06.814 --> 01:21:08.695
<v SPEAKER_02>How would you address that?

1545
01:21:08.756 --> 01:21:10.517
<v SPEAKER_02>It's more like a quick mistake to fix that.

1546
01:21:10.617 --> 01:21:11.978
<v SPEAKER_02>Oh, yeah, this is overlapping.

1547
01:21:11.998 --> 01:21:16.681
<v SPEAKER_02>But I guess reacting to that comment and then also giving me

1548
01:21:17.691 --> 01:21:22.393
<v SPEAKER_02> Maybe, do you have, can you be honest about the issues that you do still encounter?

1549
01:21:22.693 --> 01:21:23.213
<v SPEAKER_00>Yes, well.

1550
01:21:23.333 --> 01:21:24.393
<v SPEAKER_02>In memory management.

1551
01:21:25.874 --> 01:21:26.514
<v SPEAKER_00>Yeah,

1552
01:21:26.734 --> 01:21:27.094
<v SPEAKER_00>so yeah,

1553
01:21:27.514 --> 01:21:29.915
<v SPEAKER_00>a useful point here to make in response to that is like,

1554
01:21:30.715 --> 01:21:32.416
<v SPEAKER_00>even though an arena is a very useful tool,

1555
01:21:32.536 --> 01:21:34.317
<v SPEAKER_00>they're not an excuse to like not

1556
01:21:35.267 --> 01:21:37.468
<v SPEAKER_00> be a programmer and think about programming.

1557
01:21:37.548 --> 01:21:39.688
<v SPEAKER_00>So you can't get away from everything.

1558
01:21:40.129 --> 01:21:42.129
<v SPEAKER_00>It's just a useful organizational tool.

1559
01:21:43.530 --> 01:21:47.211
<v SPEAKER_00>So as an example of a memory bug you can have with an arena is if you return a

1560
01:21:47.231 --> 01:21:48.511
<v SPEAKER_00>pointer to a portion that gets popped.

1561
01:21:51.552 --> 01:21:56.618
<v SPEAKER_00> And so the bug you'll see Martins present later is me doing this, but with a stack, not the arena.

1562
01:21:56.658 --> 01:21:57.619
<v SPEAKER_00>But same concept, right?

1563
01:21:57.639 --> 01:22:02.163
<v SPEAKER_00>You can return a pointer to something higher up on the stack after you've technically popped it off.

1564
01:22:02.644 --> 01:22:04.145
<v SPEAKER_00>Might work for a long time.

1565
01:22:04.366 --> 01:22:07.128
<v SPEAKER_00>I never caught that bug, but Martins did.

1566
01:22:07.188 --> 01:22:11.193
<v SPEAKER_00>But stuff like that can happen.

1567
01:22:11.273 --> 01:22:12.494
<v SPEAKER_00>Now, there are some tools you can do,

1568
01:22:14.527 --> 01:22:18.310
<v SPEAKER_00> There are some approaches you can have to quickly diagnosing and fixing those problems.

1569
01:22:19.611 --> 01:22:25.855
<v SPEAKER_00>Usually I don't tend to find them that frequently, so I kind of don't go this far in most cases.

1570
01:22:25.975 --> 01:22:30.038
<v SPEAKER_00>But if you do have something like a leak on an arena,

1571
01:22:30.158 --> 01:22:32.360
<v SPEAKER_00>or you have exactly what you said,

1572
01:22:32.400 --> 01:22:34.141
<v SPEAKER_00>like dangling pointers or something like that,

1573
01:22:34.861 --> 01:22:37.763
<v SPEAKER_00>what you can do with one example,

1574
01:22:37.964 --> 01:22:39.064
<v SPEAKER_00>I don't know a way to sum it up,

1575
01:22:39.104 --> 01:22:42.267
<v SPEAKER_00>but one example would be every time you call that get scratch function,

1576
01:22:43.047 --> 01:22:44.207
<v SPEAKER_00>or arena temp begin,

1577
01:22:44.487 --> 01:22:47.968
<v SPEAKER_00>those two functions that begin a sub-lifetime inside of an arena,

1578
01:22:48.448 --> 01:22:51.969
<v SPEAKER_00>what you would do that could be helpful is bump to a page boundary.

1579
01:22:52.749 --> 01:22:53.710
<v SPEAKER_00>And then when you pop,

1580
01:22:54.490 --> 01:22:57.151
<v SPEAKER_00>any pages that you would have pushed over that page boundary,

1581
01:22:57.531 --> 01:22:58.571
<v SPEAKER_00>mark them as no access.

1582
01:22:59.451 --> 01:23:04.492
<v SPEAKER_00>So you just say to the operating system, these pages that I was pushing on, I'm popping them off.

1583
01:23:04.572 --> 01:23:09.014
<v SPEAKER_00>So if anyone touches those pages again, I want you to throw an exception.

1584
01:23:09.474 --> 01:23:09.954
<v SPEAKER_00>And you can do that.

1585
01:23:10.994 --> 01:23:18.555
<v SPEAKER_00>And because it's just this one layer where you control the allocator,

1586
01:23:18.655 --> 01:23:19.936
<v SPEAKER_00>you can simply do that kind of thing.

1587
01:23:20.156 --> 01:23:21.436
<v SPEAKER_00>With a memory leak, it's the same thing.

1588
01:23:21.456 --> 01:23:28.877
<v SPEAKER_00>You can say if the push size or if the committed memory is larger than 256 megabytes,

1589
01:23:30.678 --> 01:23:33.278
<v SPEAKER_00>debug break and tell me in the debugger.

1590
01:23:33.538 --> 01:23:37.399
<v SPEAKER_00>And you can detect things like that pretty easily because you just have that slim layer there.

1591
01:23:41.548 --> 01:23:43.030
<v SPEAKER_00> Uh-oh.

1592
01:23:46.594 --> 01:23:46.934
<v SPEAKER_00>Oh, OK.

1593
01:23:47.074 --> 01:23:47.475
<v SPEAKER_00>Perfect.

1594
01:23:48.256 --> 01:23:48.936
<v SPEAKER_00>Some Martin's advice.

1595
01:23:48.956 --> 01:23:49.097
<v SPEAKER_00>Yes.

1596
01:23:49.157 --> 01:23:49.337
<v SPEAKER_00>Yes.

1597
01:23:49.357 --> 01:23:49.517
<v SPEAKER_00>Yeah.

1598
01:23:56.832 --> 01:23:57.132
<v SPEAKER_00> For sure.

1599
01:23:57.352 --> 01:23:58.573
<v SPEAKER_00>I'm very much looking forward to your talk,

1600
01:23:58.593 --> 01:24:00.773
<v SPEAKER_00>because I'm terrible about using stuff like address sanitizer.

1601
01:24:00.793 --> 01:24:02.654
<v SPEAKER_00>But that being said,

1602
01:24:02.674 --> 01:24:06.055
<v SPEAKER_00>the arena being an organizational tool has helped me avoid a lot of the things that

1603
01:24:06.575 --> 01:24:08.056
<v SPEAKER_00>you kind of need that stuff for.

1604
01:24:08.076 --> 01:24:11.117
<v SPEAKER_00>But I will never say you just don't need them.

1605
01:24:11.177 --> 01:24:12.137
<v SPEAKER_00>Those are useful tools.

1606
01:24:12.817 --> 01:24:17.199
<v SPEAKER_00>It's just that you don't produce as many problems when you do things in a little bit more organized way.

1607
01:24:18.456 --> 01:24:21.399
<v SPEAKER_02>just mentioned that you'll be a speaker tomorrow that you can use the address

1608
01:24:21.419 --> 01:24:24.602
<v SPEAKER_02>sanitizer to catch these things as well.

1609
01:24:24.942 --> 01:24:25.702
<v SPEAKER_02>So thank you for that.

1610
01:24:26.363 --> 01:24:27.884
<v SPEAKER_02>So enable ASAM, people.

1611
01:24:29.206 --> 01:24:31.307
<v SPEAKER_02>And to be terrible here,

1612
01:24:31.387 --> 01:24:31.568
<v SPEAKER_02>again,

1613
01:24:31.588 --> 01:24:37.213
<v SPEAKER_02>the memory problems I encountered in my C program after using the strategy are

1614
01:24:37.253 --> 01:24:38.133
<v SPEAKER_02>effectively zero.

1615
01:24:40.652 --> 01:24:41.312
<v SPEAKER_02> It's not exactly zero.

1616
01:24:41.332 --> 01:24:43.794
<v SPEAKER_02>So there's one or two issues that we just talked about.

1617
01:24:43.814 --> 01:24:46.255
<v SPEAKER_02>So I appreciate the tips there.

1618
01:24:46.595 --> 01:24:46.775
<v SPEAKER_00>Yeah.

1619
01:24:46.955 --> 01:24:48.636
<v SPEAKER_00>And I could add one more thing on that.

1620
01:24:51.037 --> 01:24:53.158
<v SPEAKER_00>When people talk about memory safety or memory safe code,

1621
01:24:53.378 --> 01:24:56.680
<v SPEAKER_00>I think it's worth digging into what that definition is.

1622
01:24:56.900 --> 01:25:03.063
<v SPEAKER_00>So when people say, I want my code to be memory safe, for example, what does that fundamentally mean?

1623
01:25:03.103 --> 01:25:06.524
<v SPEAKER_00>What's the important content in that kind of a statement?

1624
01:25:06.844 --> 01:25:10.286
<v SPEAKER_00>It's like, well, you want your code to run correctly with no memory bugs under all circumstances.

1625
01:25:10.606 --> 01:25:12.907
<v SPEAKER_00> Which means you could have memory safe code in assembly.

1626
01:25:13.347 --> 01:25:16.088
<v SPEAKER_00>Because you can prove things about the way your code is going to run in all cases.

1627
01:25:16.548 --> 01:25:19.689
<v SPEAKER_00>And so you don't need, that's the true important property.

1628
01:25:19.709 --> 01:25:23.570
<v SPEAKER_00>I'm not saying higher level tools don't help you check for certain cases or something like that.

1629
01:25:23.590 --> 01:25:24.350
<v SPEAKER_00>I don't mean to say that.

1630
01:25:25.671 --> 01:25:28.472
<v SPEAKER_00>But I just mean it's a problem about correctness in all circumstances.

1631
01:25:29.272 --> 01:25:32.713
<v SPEAKER_00> And so I think that's a useful thing to consider.

1632
01:25:32.773 --> 01:25:37.295
<v SPEAKER_00>And when you are organized about how you approach the problem of memory management

1633
01:25:37.315 --> 01:25:37.836
<v SPEAKER_00>and see it's like,

1634
01:25:38.376 --> 01:25:43.118
<v SPEAKER_00>you just kind of get a lot better at tackling those problems and being able to

1635
01:25:43.158 --> 01:25:44.838
<v SPEAKER_00>prove things about the way your code will execute.

1636
01:25:44.858 --> 01:25:45.099
<v SPEAKER_00>Last comment.

1637
01:25:45.119 --> 01:25:49.400
<v SPEAKER_02>I'm a little bit.

1638
01:25:49.420 --> 01:25:50.201
<v SPEAKER_02>I'm so sorry.

1639
01:25:52.320 --> 01:25:53.521
<v SPEAKER_02>With something like Rust,

1640
01:25:53.581 --> 01:25:56.203
<v SPEAKER_02>which does say it's memory-saving,

1641
01:25:57.143 --> 01:25:58.484
<v SPEAKER_02>all the Rust people here know,

1642
01:25:58.564 --> 01:25:59.285
<v SPEAKER_02>you know,

1643
01:25:59.305 --> 01:26:01.586
<v SPEAKER_02>I like to be spicy in Miami Conference.

1644
01:26:03.968 --> 01:26:07.350
<v SPEAKER_02>There is a cost that you pay for that memory-saving.

1645
01:26:07.390 --> 01:26:08.871
<v SPEAKER_02>It's like you put it to a straightjacket.

1646
01:26:08.911 --> 01:26:12.814
<v SPEAKER_02>You have to follow the rules of the compiler time,

1647
01:26:12.834 --> 01:26:13.534
<v SPEAKER_02>memory-safety checks,

1648
01:26:13.614 --> 01:26:19.138
<v SPEAKER_02>and it's a difficult pill to swallow in order to get that memory-safety where

1649
01:26:24.349 --> 01:26:26.935
<v SPEAKER_02> with most of the memory safety concerns addressed

1650
01:26:31.520 --> 01:26:31.660
<v SPEAKER_02> Yeah.

1651
01:27:02.312 --> 01:27:04.274
<v SPEAKER_00>I also have the exercise to get through,

1652
01:27:04.774 --> 01:27:05.995
<v SPEAKER_00>so I can go through those,

1653
01:27:06.896 --> 01:27:08.297
<v SPEAKER_00>because I was going to do those after the demo.

1654
01:27:08.317 --> 01:27:13.922
<v SPEAKER_00>So I can just walk through them for people who are interested in the sort of problems that I outlined.

1655
01:27:13.942 --> 01:27:17.124
<v SPEAKER_02>You still have 25 minutes, so there's still time for a few more.

1656
01:27:17.144 --> 01:27:18.065
<v SPEAKER_00>OK, yeah, yeah, sure, yeah.

1657
01:27:18.085 --> 01:27:19.907
<v SPEAKER_00>I'll just get ready to answer, but I'll still.

1658
01:27:19.927 --> 01:27:20.807
<v SPEAKER_00>Oh, do you want me to do it right now, or?

1659
01:27:20.827 --> 01:27:21.888
<v SPEAKER_00>If you have it, you have a question.

1660
01:27:21.908 --> 01:27:27.012
<v SPEAKER_02>OK, let's address those questions.

1661
01:27:27.032 --> 01:27:27.653
<v SPEAKER_00>All right, sure, yeah.

1662
01:27:31.741 --> 01:27:39.164
<v SPEAKER_02> So I feel certain that in most cases, you're going to get a speedup, but probably a significant speedup.

1663
01:27:39.484 --> 01:27:43.945
<v SPEAKER_02>But I'd like to clarify that with some specific examples, if you know of any.

1664
01:27:44.466 --> 01:27:49.007
<v SPEAKER_02>Do you have any case studies or examples where you were using,

1665
01:27:49.647 --> 01:27:51.468
<v SPEAKER_02>you came to some code,

1666
01:27:51.928 --> 01:27:54.389
<v SPEAKER_02>there was use of these everywhere,

1667
01:27:54.829 --> 01:27:56.970
<v SPEAKER_02>built by this and if so,

1668
01:27:58.953 --> 01:27:59.173
<v SPEAKER_00>Yeah,

1669
01:27:59.193 --> 01:28:00.193
<v SPEAKER_00>so the question was,

1670
01:28:00.233 --> 01:28:04.715
<v SPEAKER_00>do you have any specific case studies or examples about switching to this

1671
01:28:04.995 --> 01:28:06.815
<v SPEAKER_00>arena-style allocation thing,

1672
01:28:07.095 --> 01:28:08.136
<v SPEAKER_00>providing a massive speed-up?

1673
01:28:09.456 --> 01:28:11.036
<v SPEAKER_00>And to answer the question directly,

1674
01:28:11.897 --> 01:28:12.337
<v SPEAKER_00>for me,

1675
01:28:12.677 --> 01:28:16.818
<v SPEAKER_00>I'm not much of a performance grind-to-the-metal kind of programmer.

1676
01:28:16.898 --> 01:28:20.219
<v SPEAKER_00>So me, personally, no.

1677
01:28:20.379 --> 01:28:25.220
<v SPEAKER_00>But there was a very good one presented at Handmade Seattle, I think, one or two years ago.

1678
01:28:25.280 --> 01:28:25.780
<v SPEAKER_00>I can't remember.

1679
01:28:28.041 --> 01:28:30.724
<v SPEAKER_00> I'm going to butcher his name, Andreas Fredriksen, I think.

1680
01:28:31.024 --> 01:28:35.669
<v SPEAKER_00>And he had the JSON parsing thing, where he took a very popular C JSON parsing library.

1681
01:28:37.791 --> 01:28:39.112
<v SPEAKER_00>I don't remember which one it was,

1682
01:28:39.152 --> 01:28:42.996
<v SPEAKER_00>but it was basically exactly the malloc and free forest style approach to the problem.

1683
01:28:43.817 --> 01:28:45.959
<v SPEAKER_00>And a ton of time was being spent in the allocator.

1684
01:28:48.582 --> 01:28:50.704
<v SPEAKER_00>He just went and replaced that with a linear bump allocator,

1685
01:28:50.724 --> 01:28:54.207
<v SPEAKER_00>which is what you get in the common case with a growable arena.

1686
01:28:54.467 --> 01:28:56.048
<v SPEAKER_00>And you can tweak it to make,

1687
01:28:56.068 --> 01:28:58.590
<v SPEAKER_00>if you can upfront commit or upfront reserve,

1688
01:28:58.610 --> 01:29:01.193
<v SPEAKER_00>you can tweak things to make it better for a particular case after the fact.

1689
01:29:02.053 --> 01:29:03.695
<v SPEAKER_00>But it eliminated a ton of time.

1690
01:29:03.715 --> 01:29:05.596
<v SPEAKER_00>I don't remember numbers off the top of my head,

1691
01:29:05.676 --> 01:29:11.381
<v SPEAKER_00>but you're turning interacting with this complicated generic general purpose

1692
01:29:11.441 --> 01:29:12.302
<v SPEAKER_00>allocator into

1693
01:29:12.862 --> 01:29:14.003
<v SPEAKER_00> grab a pointer and then add.

1694
01:29:14.604 --> 01:29:17.146
<v SPEAKER_00>So it turns into almost nothing in a common case.

1695
01:29:18.667 --> 01:29:22.090
<v SPEAKER_00>But yeah, for a specific case study, no, not except for that talk.

1696
01:29:22.110 --> 01:29:23.311
<v SPEAKER_00>That's the best example I ever saw.

1697
01:29:23.331 --> 01:29:24.112
<v SPEAKER_00>I just kind of switched.

1698
01:29:24.312 --> 01:29:27.415
<v SPEAKER_00>And for me, it was more about correctness and not screwing up.

1699
01:29:27.875 --> 01:29:29.176
<v SPEAKER_00>So hopefully that makes sense.

1700
01:29:29.637 --> 01:29:33.400
<v SPEAKER_00>I'm probably the wrong person to ask about performance numbers and stuff like that.

1701
01:29:33.460 --> 01:29:36.262
<v SPEAKER_00>But yeah, I think there's lots of good examples out there.

1702
01:29:37.203 --> 01:29:38.824
<v SPEAKER_00>But that's the one that I remember.

1703
01:29:44.093 --> 01:29:45.314
<v SPEAKER_00> Oh, for the JSON one?

1704
01:29:45.414 --> 01:29:46.334
<v SPEAKER_00>Yeah, yeah, yeah, for sure.

1705
01:29:48.595 --> 01:29:49.675
<v SPEAKER_00>Yeah, yeah, definitely.

1706
01:29:49.896 --> 01:29:50.996
<v SPEAKER_00>Yeah, I remember it being huge.

1707
01:29:51.016 --> 01:29:54.057
<v SPEAKER_00>It was like a ton of time was being spent just in the allocator.

1708
01:29:54.097 --> 01:29:54.197
<v SPEAKER_00>Now,

1709
01:29:54.558 --> 01:29:56.478
<v SPEAKER_00>some cases it won't make that big of a difference because,

1710
01:29:56.738 --> 01:29:57.459
<v SPEAKER_00>like I said earlier,

1711
01:29:57.699 --> 01:30:00.820
<v SPEAKER_00>malloc is sort of best case getting to what an arena would have given you.

1712
01:30:01.300 --> 01:30:03.201
<v SPEAKER_00>And sometimes it does, depending on usage pattern.

1713
01:30:03.241 --> 01:30:04.242
<v SPEAKER_00>But sometimes it also doesn't.

1714
01:30:04.422 --> 01:30:05.082
<v SPEAKER_00>So, yeah.

1715
01:30:15.695 --> 01:30:16.075
<v SPEAKER_02> Oh wow.

1716
01:30:16.315 --> 01:30:16.575
<v SPEAKER_02>Yeah.

1717
01:30:50.202 --> 01:30:59.566
 Yeah.

1718
01:31:03.067 --> 01:31:04.708
<v SPEAKER_00>Yeah, that's a great example.

1719
01:31:07.079 --> 01:31:09.381
<v SPEAKER_00> Yeah, and that's a, sorry, one follow-up comment on that.

1720
01:31:09.441 --> 01:31:10.361
<v SPEAKER_00>I think that's a good example of,

1721
01:31:10.401 --> 01:31:10.562
<v SPEAKER_00>like,

1722
01:31:10.982 --> 01:31:15.785
<v SPEAKER_00>how the don't allocate in a hot loop advice makes some sense under some circumstances,

1723
01:31:16.246 --> 01:31:16.586
<v SPEAKER_00>but if you,

1724
01:31:16.626 --> 01:31:16.786
<v SPEAKER_00>like,

1725
01:31:16.826 --> 01:31:18.267
<v SPEAKER_00>change what it means to dynamically allocate,

1726
01:31:18.287 --> 01:31:18.968
<v SPEAKER_00>it actually becomes,

1727
01:31:19.008 --> 01:31:19.148
<v SPEAKER_00>like,

1728
01:31:19.228 --> 01:31:20.109
<v SPEAKER_00>much less of a problem,

1729
01:31:20.169 --> 01:31:20.329
<v SPEAKER_00>right?

1730
01:31:20.349 --> 01:31:20.509
<v SPEAKER_00>So, yeah.

1731
01:31:20.729 --> 01:31:22.710
<v SPEAKER_00>Yeah, that was a good example.

1732
01:31:23.391 --> 01:31:27.194
<v SPEAKER_01>So, my first question was, so can you show the code

1733
01:31:35.620 --> 01:31:37.121
 in GUI or something like that.

1734
01:31:37.421 --> 01:31:40.362
Would you rematerialize the strings in a temporary arena?

1735
01:31:40.622 --> 01:31:41.703
<v SPEAKER_03>Like a temporary scratch?

1736
01:31:41.803 --> 01:31:43.423
<v SPEAKER_03>So you basically run through the thing,

1737
01:31:44.504 --> 01:31:46.005
allocate a scratch buffer there,

1738
01:31:46.445 --> 01:31:49.146
<v SPEAKER_01>and then pass that to in GUI or some other tool.

1739
01:31:50.089 --> 01:31:53.450
<v SPEAKER_00> Yeah, so it's my own UI, but it would work the same way.

1740
01:31:53.490 --> 01:31:54.891
<v SPEAKER_00>So what I do, you can see it right here.

1741
01:31:55.651 --> 01:31:57.052
<v SPEAKER_00>When I'm grabbing an entity name,

1742
01:31:57.152 --> 01:31:58.173
<v SPEAKER_00>I have this function that's just like,

1743
01:31:58.533 --> 01:31:59.733
<v SPEAKER_00>get me the name from an entity,

1744
01:32:00.113 --> 01:32:00.954
<v SPEAKER_00>and I pass an arena.

1745
01:32:01.154 --> 01:32:01.774
<v SPEAKER_00>So I just say,

1746
01:32:02.674 --> 01:32:03.535
<v SPEAKER_00>hopefully it's visible,

1747
01:32:03.555 --> 01:32:05.576
<v SPEAKER_00>but I say,

1748
01:32:06.016 --> 01:32:06.716
<v SPEAKER_00>name from entity,

1749
01:32:07.497 --> 01:32:08.517
<v SPEAKER_00>put it onto the scratch arena,

1750
01:32:08.537 --> 01:32:09.597
<v SPEAKER_00>and then I pass in the entity.

1751
01:32:10.518 --> 01:32:15.520
<v SPEAKER_00>And if we look at what that does, oh, sorry, this is from a different project.

1752
01:32:16.580 --> 01:32:17.741
<v SPEAKER_00>I've got the same thing elsewhere.

1753
01:32:19.572 --> 01:32:19.892
<v SPEAKER_00> Shoot.

1754
01:32:21.053 --> 01:32:21.374
<v SPEAKER_00>There we go.

1755
01:32:22.234 --> 01:32:24.516
<v SPEAKER_00>And you can see it's doing exactly what you just said.

1756
01:32:24.796 --> 01:32:31.541
<v SPEAKER_00>It's pushing the buffer memcopying portions into it, because memcopy is very, very cheap.

1757
01:32:33.643 --> 01:32:36.485
<v SPEAKER_00>There's such a small amount of data that in a case like this,

1758
01:32:36.505 --> 01:32:37.145
<v SPEAKER_00>like these small,

1759
01:32:37.185 --> 01:32:38.306
<v SPEAKER_00>variably sized strings,

1760
01:32:38.366 --> 01:32:40.348
<v SPEAKER_00>it's actually pretty reasonable to do that.

1761
01:32:40.368 --> 01:32:43.230
<v SPEAKER_02>And my second question was,

1762
01:32:51.674 --> 01:33:04.378
<v SPEAKER_01> Yeah, so how do you take arenas and go wide?

1763
01:33:04.418 --> 01:33:07.420
<v SPEAKER_00>How do you think about arenas as they relate to multiple threads?

1764
01:33:08.020 --> 01:33:09.440
<v SPEAKER_00>In many cases, it's exactly as you say.

1765
01:33:09.640 --> 01:33:10.661
<v SPEAKER_00>A thread will

1766
01:33:12.891 --> 01:33:15.693
<v SPEAKER_00> it will have its own arena that it's going to be pushing onto.

1767
01:33:15.953 --> 01:33:18.915
<v SPEAKER_00>Therefore, nobody else is going to be pushing onto it, no contention or anything like that.

1768
01:33:19.596 --> 01:33:20.596
<v SPEAKER_00>There are other cases when,

1769
01:33:20.716 --> 01:33:21.137
<v SPEAKER_00>for example,

1770
01:33:21.157 --> 01:33:24.399
<v SPEAKER_00>if you did want a shared data structure between multiple threads,

1771
01:33:24.960 --> 01:33:29.423
<v SPEAKER_00>you might have an arena that corresponds not to a particular thread,

1772
01:33:29.463 --> 01:33:30.604
<v SPEAKER_00>but to the data structure itself.

1773
01:33:30.664 --> 01:33:35.327
<v SPEAKER_00>And that way, you would have to... I don't have any kind of special arenas where I put locks into it.

1774
01:33:35.387 --> 01:33:35.607
<v SPEAKER_00>I just...

1775
01:33:36.468 --> 01:33:38.809
<v SPEAKER_00> use locking with an arena to implement that effect.

1776
01:33:38.929 --> 01:33:43.651
<v SPEAKER_00>So I kind of pull it out of the implementation details there, because I'm doing multi-thread stuff.

1777
01:33:43.731 --> 01:33:45.912
<v SPEAKER_00>It's like that's the layer where it should be solved, in my opinion.

1778
01:33:45.952 --> 01:33:47.593
<v SPEAKER_00>But yeah,

1779
01:33:48.393 --> 01:33:49.474
<v SPEAKER_00>kind of exactly as you say,

1780
01:33:49.514 --> 01:33:52.935
<v SPEAKER_00>it's like arenas are most coherent when they're used by a single thread at a time.

1781
01:33:53.796 --> 01:33:57.698
<v SPEAKER_00>And so that could either be a shared data structure, or it could just be one thread that only touches it.

1782
01:33:57.718 --> 01:33:58.398
<v SPEAKER_00>So yeah.

1783
01:34:00.899 --> 01:34:01.660
<v SPEAKER_00> That's kind of the idea.

1784
01:34:01.680 --> 01:34:02.941
<v SPEAKER_00>There's also other things you can do,

1785
01:34:03.041 --> 01:34:05.783
<v SPEAKER_00>like if you expect contention between multiple threads,

1786
01:34:05.883 --> 01:34:13.268
<v SPEAKER_00>you could reserve multiple arenas so that you sort of shrink the probability that

1787
01:34:13.308 --> 01:34:16.190
<v SPEAKER_00>two threads will have to contend with one another because they might hit different slots,

1788
01:34:16.631 --> 01:34:17.631
<v SPEAKER_00>and each slot has an arena,

1789
01:34:17.651 --> 01:34:18.192
<v SPEAKER_00>something like that.

1790
01:34:18.632 --> 01:34:22.215
<v SPEAKER_00>So hopefully that answers the question.

1791
01:34:22.235 --> 01:34:25.177
<v SPEAKER_02>Anybody else have a question?

1792
01:34:25.197 --> 01:34:27.859
<v SPEAKER_02>All right, so we'll do one more, and then we can try it now.

1793
01:34:28.871 --> 01:34:29.932
<v SPEAKER_00> Or you mean the exercises?

1794
01:34:29.952 --> 01:34:30.152
<v SPEAKER_02>Yeah.

1795
01:34:30.372 --> 01:34:34.034
<v SPEAKER_02>Well, you were going to show something, right?

1796
01:34:34.054 --> 01:34:34.214
<v SPEAKER_02>Was I?

1797
01:34:34.234 --> 01:34:35.034
<v SPEAKER_02>You already showed it.

1798
01:34:35.515 --> 01:34:37.496
<v SPEAKER_02>You see what happens when I leave the room for a couple minutes.

1799
01:34:37.556 --> 01:34:39.677
<v SPEAKER_02>Raise your hand again for the question.

1800
01:34:47.663 --> 01:34:50.524
<v SPEAKER_02> All right, so I just got some kind of newbie questions here.

1801
01:34:50.644 --> 01:34:53.605
<v SPEAKER_02>That was the first time I've seen your earlier example,

1802
01:34:53.645 --> 01:34:58.847
<v SPEAKER_02>just regular stack memory freeing being like the end bracket.

1803
01:34:59.207 --> 01:35:04.369
<v SPEAKER_02>I'm assuming the cost of freeing is not the same as the heap allocation,

1804
01:35:04.689 --> 01:35:07.750
<v SPEAKER_02>but can you say more about,

1805
01:35:08.030 --> 01:35:09.331
<v SPEAKER_02>does it have a cost that we

1806
01:35:11.909 --> 01:35:12.109
<v SPEAKER_00>Yeah,

1807
01:35:12.129 --> 01:35:15.611
<v SPEAKER_00>so you'd have to go look at specific implementations of the more general purpose

1808
01:35:15.651 --> 01:35:16.451
<v SPEAKER_00>allocators to know.

1809
01:35:17.151 --> 01:35:19.313
<v SPEAKER_00>Freeing is generally not free, despite the name.

1810
01:35:20.473 --> 01:35:22.834
<v SPEAKER_00>But in some cases, it can be very fast.

1811
01:35:24.875 --> 01:35:28.097
<v SPEAKER_00>So with an arena, it's what you saw.

1812
01:35:28.237 --> 01:35:29.297
<v SPEAKER_00>You set the pointer back.

1813
01:35:29.457 --> 01:35:30.098
<v SPEAKER_00>So it's very cheap.

1814
01:35:31.098 --> 01:35:32.499
<v SPEAKER_00>You can optionally also,

1815
01:35:32.539 --> 01:35:35.902
<v SPEAKER_00>if you've physically committed a lot of memory and you pop all of it off or something,

1816
01:35:35.922 --> 01:35:36.942
<v SPEAKER_00>you want to decommit some of it,

1817
01:35:37.162 --> 01:35:37.923
<v SPEAKER_00>then it's more expensive.

1818
01:35:38.043 --> 01:35:43.527
<v SPEAKER_00>Then you have to do this syscall to tell the operating system that you no longer want those pages around.

1819
01:35:45.248 --> 01:35:45.769
<v SPEAKER_00>But yeah,

1820
01:35:45.929 --> 01:35:49.251
<v SPEAKER_00>when you call malloc or free or any equivalent allocator,

1821
01:35:49.351 --> 01:35:51.693
<v SPEAKER_00>they're managing a much more sophisticated data structure.

1822
01:35:53.414 --> 01:35:57.737
<v SPEAKER_00> When you call free, it just depends on the strategies.

1823
01:35:57.757 --> 01:36:01.860
<v SPEAKER_00>There are tons of strategies they have to make contiguous to multiple free chunks

1824
01:36:01.880 --> 01:36:03.061
<v SPEAKER_00>that happen to be next to each other.

1825
01:36:03.081 --> 01:36:05.403
<v SPEAKER_00>There's a lot of extra work that happens there.

1826
01:36:06.504 --> 01:36:08.325
<v SPEAKER_00>But you have to look at the implementation to know for sure.

1827
01:36:08.365 --> 01:36:10.346
<v SPEAKER_00>But it generally will be more complicated, yeah.

1828
01:36:10.607 --> 01:36:10.867
<v SPEAKER_02>Got you.

1829
01:36:10.907 --> 01:36:12.188
<v SPEAKER_02>Just one more question.

1830
01:36:13.626 --> 01:36:17.692
<v SPEAKER_02> You're mentioning the difference between reserving memory versus allocating it.

1831
01:36:18.153 --> 01:36:22.559
<v SPEAKER_02>And I was trying to wrap my brain around the idea of reserving.

1832
01:36:22.719 --> 01:36:26.705
<v SPEAKER_02>Is that just saying, hey, we're going to start allocating from this position in memory.

1833
01:36:27.086 --> 01:36:28.808
<v SPEAKER_02>For this other arena, we're going to start here.

1834
01:36:31.414 --> 01:36:37.596
<v SPEAKER_00> No, yeah, so I have a slide in the self-driven exercises that will maybe cover this.

1835
01:36:37.636 --> 01:36:39.497
<v SPEAKER_00>But when you reserve address space,

1836
01:36:39.677 --> 01:36:42.038
<v SPEAKER_00>all you're sort of doing is telling the operating system,

1837
01:36:42.058 --> 01:36:43.619
<v SPEAKER_00>which is managing your address space,

1838
01:36:44.419 --> 01:36:45.119
<v SPEAKER_00>that nobody,

1839
01:36:45.380 --> 01:36:47.640
<v SPEAKER_00>you should not give out these addresses,

1840
01:36:47.700 --> 01:36:49.241
<v SPEAKER_00>this range of addresses.

1841
01:36:49.281 --> 01:36:52.842
<v SPEAKER_00>So when I refer to this address as a number up to this address as a number,

1842
01:36:54.563 --> 01:36:56.044
<v SPEAKER_00>nobody else should be given those addresses.

1843
01:36:57.284 --> 01:36:59.846
<v SPEAKER_00> But you don't have physical resources backing them yet.

1844
01:36:59.966 --> 01:37:06.852
<v SPEAKER_00>So you still can have pointers to that that you expect to read or write to at some point.

1845
01:37:06.872 --> 01:37:10.135
<v SPEAKER_00>But it has to be backed by physical memory if you expect to use memory, right?

1846
01:37:12.757 --> 01:37:14.678
<v SPEAKER_00> And there is some bookkeeping, too.

1847
01:37:14.898 --> 01:37:16.318
<v SPEAKER_00>Reserving address space is not free.

1848
01:37:16.338 --> 01:37:20.459
<v SPEAKER_00>It does cost physical memory that the operating system has to manage to maintain

1849
01:37:20.939 --> 01:37:23.720
<v SPEAKER_00>which pages or which portions of address space you have reserved.

1850
01:37:24.240 --> 01:37:31.222
<v SPEAKER_00>But it is sort of saying this arbitrary range of numbers is reserved by that has

1851
01:37:31.262 --> 01:37:32.263
<v SPEAKER_00>been allocated effectively.

1852
01:37:32.323 --> 01:37:36.304
<v SPEAKER_00>So in the same way, it's actually kind of similar to the Atlas allocator I had.

1853
01:37:37.611 --> 01:37:42.534
<v SPEAKER_00> What I was allocating in that allocator that I wrote was not literal portions of texture memory.

1854
01:37:42.595 --> 01:37:49.179
<v SPEAKER_00>It was just numbers that look into a range of basically just an abstract space,

1855
01:37:49.219 --> 01:37:52.081
<v SPEAKER_00>like some atlas size from 0 to 1,024.

1856
01:37:52.161 --> 01:37:55.504
<v SPEAKER_00>If I allocate a region out of it, I'm not grabbing any actual memory.

1857
01:37:55.884 --> 01:38:01.027
<v SPEAKER_00>I'm just saying, don't hand out this quadrant of this texture space out to someone else.

1858
01:38:01.087 --> 01:38:02.388
<v SPEAKER_00>And so address space is very much the same thing.

1859
01:38:02.408 --> 01:38:05.971
<v SPEAKER_00>You're just kind of saying, I want these addresses, not memory for them.

1860
01:38:06.818 --> 01:38:10.783
<v SPEAKER_02> Is there, like, a special command that you're saying, yeah, don't test this?

1861
01:38:11.184 --> 01:38:11.384
<v SPEAKER_00>Yes.

1862
01:38:11.444 --> 01:38:14.388
<v SPEAKER_00>So this is not, you can't do this from, like, the C standard library.

1863
01:38:14.748 --> 01:38:18.914
<v SPEAKER_00>You have to call into functions provided to you by the kernel,

1864
01:38:19.014 --> 01:38:20.716
<v SPEAKER_00>which would be something like on Windows,

1865
01:38:20.756 --> 01:38:21.657
<v SPEAKER_00>it would be virtual alloc.

1866
01:38:23.378 --> 01:38:29.581
<v SPEAKER_00> On Linux, Linux is trickier, but it's going to start with mmap, and then you can also do madvise.

1867
01:38:29.601 --> 01:38:31.442
<v SPEAKER_00>There are different things, but you can abstract over them.

1868
01:38:31.482 --> 01:38:36.244
<v SPEAKER_00>You can have the same kind of interface abstracting over both the Windows and Linux equivalent,

1869
01:38:36.544 --> 01:38:37.544
<v SPEAKER_00>and then get the same behavior.

1870
01:38:38.265 --> 01:38:41.426
<v SPEAKER_00>But Linux is a little trickier, and I usually do programming on Windows.

1871
01:38:42.166 --> 01:38:42.887
<v SPEAKER_00>But on Windows, it's

1872
01:38:43.607 --> 01:38:45.428
<v SPEAKER_00> Virtual alloc and virtual free is what you're going to look at.

1873
01:38:45.488 --> 01:38:47.609
<v SPEAKER_00>And based on some flags you pass in,

1874
01:38:48.049 --> 01:38:50.230
<v SPEAKER_00>you could either ask for backing memory immediately,

1875
01:38:51.391 --> 01:38:53.032
<v SPEAKER_00>or you could ask just to reserve the address space,

1876
01:38:53.052 --> 01:38:56.553
<v SPEAKER_00>which is just like virtual alloc with a mem reserve kind of thing.

1877
01:38:56.573 --> 01:38:59.675
<v SPEAKER_00>And then it's just going to allocate the address space.

1878
01:38:59.815 --> 01:39:05.918
<v SPEAKER_00>And if you try to write to any of those addresses, it'll be like you haven't committed any pages yet.

1879
01:39:05.938 --> 01:39:06.258
<v SPEAKER_00>Yeah?

1880
01:39:17.887 --> 01:39:21.856
<v SPEAKER_02> Towards the beginning of the talk you mentioned that you have 56 bits of effective

1881
01:39:26.696 --> 01:39:28.817
<v SPEAKER_00> So it's actually 48 bits.

1882
01:39:30.018 --> 01:39:31.578
<v SPEAKER_00>I use 56 later.

1883
01:39:31.979 --> 01:39:34.440
<v SPEAKER_00>But 48 bits of address space.

1884
01:39:35.200 --> 01:39:39.582
<v SPEAKER_00>And that actually changes depending on the CPU and environment you're in.

1885
01:39:39.622 --> 01:39:41.243
<v SPEAKER_00>So one example I know,

1886
01:39:41.263 --> 01:39:41.923
<v SPEAKER_00>I think,

1887
01:39:42.404 --> 01:39:43.744
<v SPEAKER_00>I don't write code for the switch,

1888
01:39:43.824 --> 01:39:47.266
<v SPEAKER_00>but I'm pretty sure based on reading things from people who do,

1889
01:39:47.706 --> 01:39:50.668
<v SPEAKER_00>that initially they had 36 bits of address space.

1890
01:39:51.568 --> 01:39:53.190
<v SPEAKER_00> And then it got bumped to 38 maybe.

1891
01:39:53.210 --> 01:39:54.972
<v SPEAKER_00>So it varies depending on device.

1892
01:39:55.013 --> 01:39:55.293
<v SPEAKER_00>Basically,

1893
01:39:55.353 --> 01:39:57.716
<v SPEAKER_00>if you're a consumer 64-bit operating system computer,

1894
01:39:57.736 --> 01:39:59.658
<v SPEAKER_00>you have your laptop or desktop or whatever.

1895
01:40:00.199 --> 01:40:01.460
<v SPEAKER_00>In some cases, I think phones.

1896
01:40:01.540 --> 01:40:04.764
<v SPEAKER_00>But I don't program for mobile either, so double check me on all that.

1897
01:40:05.565 --> 01:40:07.788
<v SPEAKER_00>It's going to be something like 48 bits of address space.

1898
01:40:07.828 --> 01:40:10.251
<v SPEAKER_00>Now, the other 12 bits, I don't know.

1899
01:40:11.980 --> 01:40:14.681
<v SPEAKER_00> That gets into the implementation details that I'm not really familiar with.

1900
01:40:15.081 --> 01:40:19.062
<v SPEAKER_00>It could be that the circuitry they have for mapping virtual addresses to physical

1901
01:40:19.422 --> 01:40:20.642
<v SPEAKER_00>addresses just couldn't,

1902
01:40:20.962 --> 01:40:23.142
<v SPEAKER_00>they didn't want to support a larger number of bits there.

1903
01:40:23.463 --> 01:40:24.203
<v SPEAKER_00>Not totally sure.

1904
01:40:24.743 --> 01:40:29.084
<v SPEAKER_00>But there's a lot of hardware implementation details to speed that process up that

1905
01:40:29.244 --> 01:40:31.284
<v SPEAKER_00>probably constrains the number of useful bits there.

1906
01:40:31.304 --> 01:40:38.926
<v SPEAKER_00>I think one thing as well is there are some addresses you can write to that will just

1907
01:40:41.818 --> 01:40:42.198
<v SPEAKER_00> Oh, interesting.

1908
01:40:42.218 --> 01:40:42.639
<v SPEAKER_00>I'm not sure.

1909
01:40:42.659 --> 01:40:43.799
<v SPEAKER_00>Yeah, I'm not sure about that.

1910
01:40:44.680 --> 01:40:44.940
<v SPEAKER_00>Maybe.

1911
01:40:44.960 --> 01:40:45.620
<v SPEAKER_00>I don't know.

1912
01:40:45.640 --> 01:40:55.526
<v SPEAKER_02>So I can comment on that issue.

1913
01:41:01.750 --> 01:41:08.794
<v SPEAKER_02>Like, what happens is, like, basically a multiple of space shables.

1914
01:41:08.834 --> 01:41:10.255
So the 48 bits

1915
01:41:13.152 --> 01:41:22.919
<v SPEAKER_02> Oh, right, for sure.

1916
01:41:27.502 --> 01:41:28.723
<v SPEAKER_02>Yeah.

1917
01:41:28.923 --> 01:41:31.705
<v SPEAKER_02>That makes sense.

1918
01:41:31.805 --> 01:41:35.768
<v SPEAKER_00>Yeah, so different levels of page tables is just where the 48-bit number comes from.

1919
01:41:35.788 --> 01:41:39.450
<v SPEAKER_00>And I think some CPUs do have a fifth-level page table deal.

1920
01:41:39.610 --> 01:41:41.932
<v SPEAKER_00>I don't know much about the implementation there, but yeah.

1921
01:41:44.520 --> 01:41:44.780
<v SPEAKER_00> Sure, yeah.

1922
01:41:45.320 --> 01:41:45.900
Oh, okay.

1923
01:41:45.961 --> 01:41:46.441
Interesting.

1924
01:41:46.461 --> 01:41:46.801
Yeah.

1925
01:41:47.041 --> 01:41:47.421
Sure, yeah.

1926
01:42:15.489 --> 01:42:17.950
<v SPEAKER_00> I'm very excited I got to this part because I have a, all right.

1927
01:42:19.652 --> 01:42:21.072
<v SPEAKER_00>So if you're interested,

1928
01:42:21.092 --> 01:42:24.234
<v SPEAKER_00>if I've convinced you that this is worth trying or looking at or something,

1929
01:42:24.595 --> 01:42:26.356
<v SPEAKER_00>I've got seven exercises.

1930
01:42:27.233 --> 01:42:31.894
<v SPEAKER_00> The first one is to just fill out this implementation with a fixed capacity arena.

1931
01:42:31.914 --> 01:42:34.394
<v SPEAKER_00>So this would be sort of like malloc a buffer.

1932
01:42:34.494 --> 01:42:39.416
<v SPEAKER_00>You could get it through malloc and just implement each of these calls.

1933
01:42:40.516 --> 01:42:43.416
<v SPEAKER_00>And it should just work like the stack.

1934
01:42:43.616 --> 01:42:45.037
<v SPEAKER_00>That's kind of exercise number one.

1935
01:42:45.457 --> 01:42:49.017
<v SPEAKER_00>And if the arena runs out of space, just crash or don't panic or whatever.

1936
01:42:49.498 --> 01:42:50.738
<v SPEAKER_00>Or no, do panic.

1937
01:42:53.740 --> 01:42:54.460
<v SPEAKER_00> Exercise number two.

1938
01:42:55.761 --> 01:43:00.083
<v SPEAKER_00>Oh, yeah, panic in the program, not like in an existential sense or something.

1939
01:43:00.763 --> 01:43:05.385
<v SPEAKER_00>Exercise number two, upgrade that arena by chaining multiple blocks together.

1940
01:43:05.445 --> 01:43:07.346
<v SPEAKER_00>So if you run out of space on the first block,

1941
01:43:08.386 --> 01:43:10.427
<v SPEAKER_00>then malloc a new block,

1942
01:43:10.527 --> 01:43:13.289
<v SPEAKER_00>and then start allocating from that block.

1943
01:43:13.309 --> 01:43:16.970
<v SPEAKER_00>And if you pop off everything from that block, move back to the first one, and so on.

1944
01:43:17.010 --> 01:43:23.053
<v SPEAKER_00>Implement the same arena, same interface with the chaining strategy as a mechanism for growth.

1945
01:43:24.752 --> 01:43:25.352
<v SPEAKER_00>And I say here,

1946
01:43:26.333 --> 01:43:28.393
<v SPEAKER_00>it should require no API changes at all,

1947
01:43:28.893 --> 01:43:31.934
<v SPEAKER_00>but you can optionally use this step to remove the initial,

1948
01:43:31.974 --> 01:43:32.154
<v SPEAKER_00>like,

1949
01:43:32.234 --> 01:43:33.094
<v SPEAKER_00>if you see this API,

1950
01:43:33.394 --> 01:43:34.775
<v SPEAKER_00>I have this U64 cap there.

1951
01:43:35.235 --> 01:43:38.896
<v SPEAKER_00>You can remove that with this step if you want to just make some default assumptions, right?

1952
01:43:41.476 --> 01:43:45.157
<v SPEAKER_00>And you can also optionally dynamically enable the feature of chaining if you,

1953
01:43:46.258 --> 01:43:48.058
<v SPEAKER_00>just so a user of an arena could maybe be like,

1954
01:43:48.178 --> 01:43:50.959
<v SPEAKER_00>I don't want this thing to chain because I'm treating it as an array or something

1955
01:43:50.979 --> 01:43:51.239
<v SPEAKER_00>like that.

1956
01:43:53.536 --> 01:43:56.137
<v SPEAKER_00> Exercise number three, just use the MMU.

1957
01:43:56.557 --> 01:44:01.999
<v SPEAKER_00>Reserve with something like Virtual Outlook or MMAP to look into your platform.

1958
01:44:02.579 --> 01:44:07.380
<v SPEAKER_00>And this would be the giant upfront address space reservation and then committing as necessary.

1959
01:44:08.741 --> 01:44:10.101
<v SPEAKER_00>Still requires no API changes.

1960
01:44:10.401 --> 01:44:12.942
<v SPEAKER_00>You can also dynamically enable it, just like the last step.

1961
01:44:14.113 --> 01:44:17.354
<v SPEAKER_00> Exercise number four, humiliate std vector.

1962
01:44:18.374 --> 01:44:20.355
<v SPEAKER_00>Use your arena from number three to implement,

1963
01:44:21.335 --> 01:44:21.796
<v SPEAKER_00>in effect,

1964
01:44:21.836 --> 01:44:23.076
<v SPEAKER_00>what you would get from an std vector,

1965
01:44:23.676 --> 01:44:25.777
<v SPEAKER_00>except the array will never relocate.

1966
01:44:25.797 --> 01:44:28.678
<v SPEAKER_00>So you never have the problem of pointers getting invalidated or anything like that.

1967
01:44:29.358 --> 01:44:31.979
<v SPEAKER_00> You just grab a pointer and you're good.

1968
01:44:32.159 --> 01:44:33.800
<v SPEAKER_00>And then, obviously, laugh at C++ with Brady.

1969
01:44:33.840 --> 01:44:35.481
<v SPEAKER_00>Now, I should add a caveat.

1970
01:44:35.881 --> 01:44:37.122
<v SPEAKER_00>I threw this in because I thought it was funny.

1971
01:44:37.662 --> 01:44:39.583
<v SPEAKER_00>If you are in a case where you want to use C++,

1972
01:44:40.584 --> 01:44:46.907
<v SPEAKER_00>you can implement an STD allocator and pass that in as in your declaration of an

1973
01:44:46.967 --> 01:44:47.487
<v SPEAKER_00>STD vector,

1974
01:44:47.547 --> 01:44:47.827
<v SPEAKER_00>I think.

1975
01:44:48.028 --> 01:44:48.448
<v SPEAKER_00>I don't do C++.

1976
01:44:48.468 --> 01:44:48.688
<v SPEAKER_00>But you can.

1977
01:44:53.090 --> 01:44:53.411
<v SPEAKER_00>do that,

1978
01:44:53.831 --> 01:44:57.976
<v SPEAKER_00>it's much more complicated than just implementing a simple malloc and freestyle

1979
01:44:58.136 --> 01:44:58.837
<v SPEAKER_00>thing or something.

1980
01:44:59.238 --> 01:45:00.740
<v SPEAKER_00>It's like a whole deal you have to do.

1981
01:45:00.860 --> 01:45:03.964
<v SPEAKER_00>But if you're in that situation, you can do that.

1982
01:45:06.539 --> 01:45:11.201
<v SPEAKER_00> Exercise number five, use your arena to implement a pool allocator using a free list.

1983
01:45:12.202 --> 01:45:13.603
<v SPEAKER_00>I cover this, I think, a lot.

1984
01:45:13.623 --> 01:45:16.984
<v SPEAKER_00>So it should follow pretty much straight from what I said earlier.

1985
01:45:18.565 --> 01:45:21.927
<v SPEAKER_00>And it's a single free list for a single size to get started.

1986
01:45:21.987 --> 01:45:24.188
<v SPEAKER_00>It's like the simple case, which basically comes up.

1987
01:45:24.788 --> 01:45:26.069
<v SPEAKER_00>It's like the 95% case,

1988
01:45:26.089 --> 01:45:26.469
<v SPEAKER_00>I would say,

1989
01:45:26.489 --> 01:45:29.871
<v SPEAKER_00>where you just have a single free list for some type that you want to allocate.

1990
01:45:30.791 --> 01:45:33.793
<v SPEAKER_00>And so you only need one free list, just fixed size, very simple.

1991
01:45:35.481 --> 01:45:36.162
<v SPEAKER_00>Exercise number six,

1992
01:45:37.042 --> 01:45:38.644
<v SPEAKER_00>just extend your arena with logging,

1993
01:45:38.684 --> 01:45:39.404
<v SPEAKER_00>visualization,

1994
01:45:39.544 --> 01:45:42.907
<v SPEAKER_00>debugging features that you can optionally turn on in a debug build or something.

1995
01:45:44.589 --> 01:45:47.451
<v SPEAKER_00>You could log things like the caller source code every time you push,

1996
01:45:47.751 --> 01:45:48.892
<v SPEAKER_00>record that information,

1997
01:45:49.993 --> 01:45:52.856
<v SPEAKER_00>and then record the arena's allocation position over time.

1998
01:45:53.156 --> 01:45:54.657
<v SPEAKER_00>So if you visualized it,

1999
01:45:54.677 --> 01:45:58.580
<v SPEAKER_00>you could see if there's a leak just visually by the arena just exploding out of control.

2000
01:46:01.063 --> 01:46:02.524
<v SPEAKER_00>And then take all that data and visualize it.

2001
01:46:04.899 --> 01:46:07.581
<v SPEAKER_00> Exercise number seven, convert real code.

2002
01:46:08.061 --> 01:46:08.902
<v SPEAKER_00>You can find a library,

2003
01:46:08.942 --> 01:46:09.963
<v SPEAKER_00>find code that you've written,

2004
01:46:10.763 --> 01:46:15.407
<v SPEAKER_00>and rethink the problem and its memory management sort of approach,

2005
01:46:15.928 --> 01:46:16.928
<v SPEAKER_00>and try to replace it.

2006
01:46:17.048 --> 01:46:19.731
<v SPEAKER_00>And then measure all the things, like someone mentioned this earlier.

2007
01:46:20.211 --> 01:46:21.052
<v SPEAKER_00>Measure the difference.

2008
01:46:21.432 --> 01:46:23.013
<v SPEAKER_00>See how many lines of code get deleted.

2009
01:46:23.253 --> 01:46:24.755
<v SPEAKER_00>See how much easier it was to write the code,

2010
01:46:24.795 --> 01:46:26.356
<v SPEAKER_00>which is not something you can measure maybe,

2011
01:46:26.376 --> 01:46:27.437
<v SPEAKER_00>but it's something you'll be able to feel.

2012
01:46:28.157 --> 01:46:29.699
<v SPEAKER_00>And also measure performance.

2013
01:46:29.719 --> 01:46:32.721
<v SPEAKER_00>Just see how things improve, or maybe they worsen.

2014
01:46:32.941 --> 01:46:33.261
<v SPEAKER_00>Let me know.

2015
01:46:33.502 --> 01:46:33.762
<v SPEAKER_00>I don't know.

2016
01:46:34.645 --> 01:46:35.666
<v SPEAKER_00> It feels like they improved me.

2017
01:46:39.370 --> 01:46:40.351
<v SPEAKER_00>And I think that's it.

2018
01:46:41.072 --> 01:46:45.636
<v SPEAKER_00>Oh yeah, and one last thing I wanted to say is there's some sort of, there's like,

2019
01:46:46.500 --> 01:46:51.965
<v SPEAKER_00> One thing I wanted to comment on is there's a lot of people who think that arenas are game dev.

2020
01:46:51.985 --> 01:46:53.386
<v SPEAKER_00>They're like, game dev people can use arenas.

2021
01:46:53.546 --> 01:46:55.148
<v SPEAKER_00>I can't use arenas because I work on something else.

2022
01:46:55.788 --> 01:46:58.330
<v SPEAKER_00>And I'm biased because I work on games.

2023
01:46:58.370 --> 01:47:01.673
<v SPEAKER_00>And that's why I put in this slide to show all the stuff I work on.

2024
01:47:03.595 --> 01:47:04.235
<v SPEAKER_00>So it's true.

2025
01:47:04.255 --> 01:47:05.717
<v SPEAKER_00>I learned this from the game development world.

2026
01:47:05.757 --> 01:47:08.259
<v SPEAKER_00>I learned it from Casey originally.

2027
01:47:09.700 --> 01:47:13.663
<v SPEAKER_00> So it's very true that it's like this technique is well known by game developers.

2028
01:47:14.403 --> 01:47:16.365
<v SPEAKER_00>But since then, I've worked on a lot of other stuff too.

2029
01:47:16.405 --> 01:47:18.166
<v SPEAKER_00>And I found the same stuff to be useful.

2030
01:47:18.226 --> 01:47:22.229
<v SPEAKER_00>So I think it's a pattern that extends much further beyond game dev.

2031
01:47:22.649 --> 01:47:27.152
<v SPEAKER_00>And I wanted to just stifle any concerns about,

2032
01:47:27.212 --> 01:47:27.372
<v SPEAKER_00>well,

2033
01:47:27.412 --> 01:47:29.634
<v SPEAKER_00>I don't want to do game development or I don't do game development.

2034
01:47:30.094 --> 01:47:30.975
<v SPEAKER_00>Is this still relevant for me?

2035
01:47:31.035 --> 01:47:32.036
<v SPEAKER_00>I would say yes.

2036
01:47:34.477 --> 01:47:35.538
<v SPEAKER_00>And that's everything.

2037
01:47:35.558 --> 01:47:35.918
<v SPEAKER_00>So thank you.

2038
01:47:40.029 --> 01:47:40.962
<v SPEAKER_00> Yeah, appreciate it.

